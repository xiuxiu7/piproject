/*
  PDD layer implementation for peripheral type NVIC
  (C) 2013 Freescale, Inc. All rights reserved.

  This file is static and it is generated from API-Factory
*/

#if !defined(NVIC_PDD_H_)
#define NVIC_PDD_H_

/* ----------------------------------------------------------------------------
   -- Test if supported MCU is active
   ---------------------------------------------------------------------------- */

#if !defined(MCU_ACTIVE)
  // No MCU is active
  #error NVIC PDD library: No derivative is active. Place proper #include with PDD memory map before including PDD library.
#elif \
      !defined(MCU_MKE04Z1284) /* NVIC */ && \
      !defined(MCU_MKE06Z4) /* NVIC */ && \
      !defined(MCU_MKV10Z7) /* NVIC */ && \
      !defined(MCU_MKW01Z4) /* NVIC */ && \
      !defined(MCU_MKW21D5) /* NVIC */ && \
      !defined(MCU_MKW21D5WS) /* NVIC */ && \
      !defined(MCU_MKW22D5) /* NVIC */ && \
      !defined(MCU_MKW22D5WS) /* NVIC */ && \
      !defined(MCU_MKW24D5) /* NVIC */ && \
      !defined(MCU_MKW24D5WS) /* NVIC */ && \
      !defined(MCU_SKEAZ1284) /* NVIC */
  // Unsupported MCU is active
  #error NVIC PDD library: Unsupported derivative is active.
#endif

#include "PDD_Types.h"

/* ----------------------------------------------------------------------------
   -- Method symbol definitions
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKE04Z1284))
/* Interrupts' mask */
  #define NVIC_PDD_FTMRE_INTERRUPT_MASK    NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_LVD_LLW_INTERRUPT_MASK  NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_IRQ_INTERRUPT_MASK      NVIC_ISER_SETENA7_MASK /**< External Interrupt interrupt vector 23 mask. */
  #define NVIC_PDD_I2C0_INTERRUPT_MASK     NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_I2C1_INTERRUPT_MASK     NVIC_ISER_SETENA9_MASK /**< Inter-Integrated Circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_SPI0_INTERRUPT_MASK     NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_SPI1_INTERRUPT_MASK     NVIC_ISER_SETENA11_MASK /**< Serial Peripheral Interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_UART0_INTERRUPT_MASK    NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_UART1_INTERRUPT_MASK    NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_UART2_INTERRUPT_MASK    NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_ADC0_INTERRUPT_MASK     NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_ACMP0_INTERRUPT_MASK    NVIC_ISER_SETENA16_MASK /**< Analog comparator 0 interrupt interrupt vector 32 mask. */
  #define NVIC_PDD_FTM0_INTERRUPT_MASK     NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_FTM1_INTERRUPT_MASK     NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_FTM2_INTERRUPT_MASK     NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_RTC_INTERRUPT_MASK      NVIC_ISER_SETENA20_MASK /**< Real-time counter interrupt vector 36 mask. */
  #define NVIC_PDD_ACMP1_INTERRUPT_MASK    NVIC_ISER_SETENA21_MASK /**< Analog comparator 1 interrupt interrupt vector 37 mask. */
  #define NVIC_PDD_PIT_CH0_INTERRUPT_MASK  NVIC_ISER_SETENA22_MASK /**< Periodic timer overflow channel 0 interrupt vector 38 mask. */
  #define NVIC_PDD_PIT_CH1_INTERRUPT_MASK  NVIC_ISER_SETENA23_MASK /**< Periodic timer overflow channel 1 interrupt vector 39 mask. */
  #define NVIC_PDD_KBI0_INTERRUPT_MASK     NVIC_ISER_SETENA24_MASK /**< Keyboard interrupt interrupt vector 40 mask. */
  #define NVIC_PDD_KBI1_INTERRUPT_MASK     NVIC_ISER_SETENA25_MASK /**< Keyboard interrupt interrupt vector 41 mask. */
  #define NVIC_PDD_ICS_INTERRUPT_MASK      NVIC_ISER_SETENA27_MASK /**< Clock loss of lock interrupt vector 43 mask. */
  #define NVIC_PDD_WDOG_EWM_INTERRUPT_MASK NVIC_ISER_SETENA28_MASK /**< WDOG interrupt vector 44 mask. */
  #define NVIC_PDD_PWT_INTERRUPT_MASK      NVIC_ISER_SETENA29_MASK /**< Pulse width timer interrupt vector 45 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR21_MASK NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR22_MASK NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR23_MASK NVIC_ISER_SETENA7_MASK /**< External Interrupt interrupt vector 23 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR24_MASK NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR25_MASK NVIC_ISER_SETENA9_MASK /**< Inter-Integrated Circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR26_MASK NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR27_MASK NVIC_ISER_SETENA11_MASK /**< Serial Peripheral Interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR28_MASK NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR29_MASK NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR30_MASK NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR31_MASK NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR32_MASK NVIC_ISER_SETENA16_MASK /**< Analog comparator 0 interrupt interrupt vector 32 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR33_MASK NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR34_MASK NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR35_MASK NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR36_MASK NVIC_ISER_SETENA20_MASK /**< Real-time counter interrupt vector 36 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR37_MASK NVIC_ISER_SETENA21_MASK /**< Analog comparator 1 interrupt interrupt vector 37 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR38_MASK NVIC_ISER_SETENA22_MASK /**< Periodic timer overflow channel 0 interrupt vector 38 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR39_MASK NVIC_ISER_SETENA23_MASK /**< Periodic timer overflow channel 1 interrupt vector 39 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR40_MASK NVIC_ISER_SETENA24_MASK /**< Keyboard interrupt interrupt vector 40 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR41_MASK NVIC_ISER_SETENA25_MASK /**< Keyboard interrupt interrupt vector 41 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR43_MASK NVIC_ISER_SETENA27_MASK /**< Clock loss of lock interrupt vector 43 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR44_MASK NVIC_ISER_SETENA28_MASK /**< WDOG interrupt vector 44 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR45_MASK NVIC_ISER_SETENA29_MASK /**< Pulse width timer interrupt vector 45 mask. */

#elif (defined(MCU_MKV10Z7))
/* Interrupts' mask */
  #define NVIC_PDD_DMA0_INTERRUPT_MASK      NVIC_ISER_SETENA0_MASK /**< DMA channel 0 transfer complete interrupt vector 16 mask. */
  #define NVIC_PDD_DMA1_INTERRUPT_MASK      NVIC_ISER_SETENA1_MASK /**< DMA channel 1 transfer complete interrupt vector 17 mask. */
  #define NVIC_PDD_DMA2_INTERRUPT_MASK      NVIC_ISER_SETENA2_MASK /**< DMA channel 2 transfer complete interrupt vector 18 mask. */
  #define NVIC_PDD_DMA3_INTERRUPT_MASK      NVIC_ISER_SETENA3_MASK /**< DMA channel 3 transfer complete interrupt vector 19 mask. */
  #define NVIC_PDD_DMA_ERROR_INTERRUPT_MASK NVIC_ISER_SETENA4_MASK /**< DMA channel 0 1 2 3 error interrupt vector 20 mask. */
  #define NVIC_PDD_FTFA_INTERRUPT_MASK      NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_PMC_INTERRUPT_MASK       NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_LLWU_INTERRUPT_MASK      NVIC_ISER_SETENA7_MASK /**< Low Leakage Wakeup interrupt vector 23 mask. */
  #define NVIC_PDD_I2C0_INTERRUPT_MASK      NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_SPI0_INTERRUPT_MASK      NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_UART0_INTERRUPT_MASK     NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_UART1_INTERRUPT_MASK     NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_ADC0_INTERRUPT_MASK      NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_ADC1_INTERRUPT_MASK      NVIC_ISER_SETENA16_MASK /**< Analog-to-Digital Converter 1 interrupt vector 32 mask. */
  #define NVIC_PDD_FTM0_INTERRUPT_MASK      NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_FTM1_INTERRUPT_MASK      NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_FTM2_INTERRUPT_MASK      NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_CMP0_INTERRUPT_MASK      NVIC_ISER_SETENA20_MASK /**< Comparator 0 interrupt vector 36 mask. */
  #define NVIC_PDD_CMP1_INTERRUPT_MASK      NVIC_ISER_SETENA21_MASK /**< Comparator 1 interrupt vector 37 mask. */
  #define NVIC_PDD_WDOG_EWM_INTERRUPT_MASK  NVIC_ISER_SETENA23_MASK /**< WDOG and EWM interrupt vector 39 mask. */
  #define NVIC_PDD_DAC0_INTERRUPT_MASK      NVIC_ISER_SETENA25_MASK /**< Digital-to-Analog Converter 0 interrupt vector 41 mask. */
  #define NVIC_PDD_MCG_INTERRUPT_MASK       NVIC_ISER_SETENA27_MASK /**< Multipurpose Clock Generator interrupt vector 43 mask. */
  #define NVIC_PDD_LPTMR0_INTERRUPT_MASK    NVIC_ISER_SETENA28_MASK /**< Low-Power Timer interrupt vector 44 mask. */
  #define NVIC_PDD_PDB0_INTERRUPT_MASK      NVIC_ISER_SETENA29_MASK /**< Programmable Delay Block interrupt vector 45 mask. */
  #define NVIC_PDD_PORTA_INTERRUPT_MASK     NVIC_ISER_SETENA30_MASK /**< GPIOA Pin detect interrupt vector 46 mask. */
  #define NVIC_PDD_PORTBCDE_INTERRUPT_MASK  NVIC_ISER_SETENA31_MASK /**< GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector 47 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR16_MASK  NVIC_ISER_SETENA0_MASK /**< DMA channel 0 transfer complete interrupt vector 16 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR17_MASK  NVIC_ISER_SETENA1_MASK /**< DMA channel 1 transfer complete interrupt vector 17 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR18_MASK  NVIC_ISER_SETENA2_MASK /**< DMA channel 2 transfer complete interrupt vector 18 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR19_MASK  NVIC_ISER_SETENA3_MASK /**< DMA channel 3 transfer complete interrupt vector 19 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR20_MASK  NVIC_ISER_SETENA4_MASK /**< DMA channel 0 1 2 3 error interrupt vector 20 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR21_MASK  NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR22_MASK  NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR23_MASK  NVIC_ISER_SETENA7_MASK /**< Low Leakage Wakeup interrupt vector 23 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR24_MASK  NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR26_MASK  NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR28_MASK  NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR29_MASK  NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR31_MASK  NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR32_MASK  NVIC_ISER_SETENA16_MASK /**< Analog-to-Digital Converter 1 interrupt vector 32 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR33_MASK  NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR34_MASK  NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR35_MASK  NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR36_MASK  NVIC_ISER_SETENA20_MASK /**< Comparator 0 interrupt vector 36 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR37_MASK  NVIC_ISER_SETENA21_MASK /**< Comparator 1 interrupt vector 37 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR39_MASK  NVIC_ISER_SETENA23_MASK /**< WDOG and EWM interrupt vector 39 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR41_MASK  NVIC_ISER_SETENA25_MASK /**< Digital-to-Analog Converter 0 interrupt vector 41 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR43_MASK  NVIC_ISER_SETENA27_MASK /**< Multipurpose Clock Generator interrupt vector 43 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR44_MASK  NVIC_ISER_SETENA28_MASK /**< Low-Power Timer interrupt vector 44 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR45_MASK  NVIC_ISER_SETENA29_MASK /**< Programmable Delay Block interrupt vector 45 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR46_MASK  NVIC_ISER_SETENA30_MASK /**< GPIOA Pin detect interrupt vector 46 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR47_MASK  NVIC_ISER_SETENA31_MASK /**< GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector 47 mask. */

#elif (defined(MCU_MKW01Z4))
/* Interrupts' mask */
  #define NVIC_PDD_DMA0_INTERRUPT_MASK        NVIC_ISER_SETENA0_MASK /**< DMA channel 0 transfer complete and error interrupt vector 16 mask. */
  #define NVIC_PDD_DMA1_INTERRUPT_MASK        NVIC_ISER_SETENA1_MASK /**< DMA channel 1 transfer complete and error interrupt vector 17 mask. */
  #define NVIC_PDD_DMA2_INTERRUPT_MASK        NVIC_ISER_SETENA2_MASK /**< DMA channel 2 transfer complete and error interrupt vector 18 mask. */
  #define NVIC_PDD_DMA3_INTERRUPT_MASK        NVIC_ISER_SETENA3_MASK /**< DMA channel 3 transfer complete and error interrupt vector 19 mask. */
  #define NVIC_PDD_FTFA_INTERRUPT_MASK        NVIC_ISER_SETENA5_MASK /**< FTFA command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_LVD_LVW_INTERRUPT_MASK     NVIC_ISER_SETENA6_MASK /**< low-voltage detect and low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_LLWU_INTERRUPT_MASK        NVIC_ISER_SETENA7_MASK /**< low leakage wakeup interrupt vector 23 mask. */
  #define NVIC_PDD_I2C0_INTERRUPT_MASK        NVIC_ISER_SETENA8_MASK /**< inter-integrated circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_I2C1_INTERRUPT_MASK        NVIC_ISER_SETENA9_MASK /**< inter-integrated circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_SPI0_INTERRUPT_MASK        NVIC_ISER_SETENA10_MASK /**< serial peripheral interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_SPI1_INTERRUPT_MASK        NVIC_ISER_SETENA11_MASK /**< serial peripheral interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_UART0_INTERRUPT_MASK       NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_UART1_INTERRUPT_MASK       NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_UART2_INTERRUPT_MASK       NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_ADC0_INTERRUPT_MASK        NVIC_ISER_SETENA15_MASK /**< Analog-to-digital converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_CMP0_INTERRUPT_MASK        NVIC_ISER_SETENA16_MASK /**< Comparator 0 interrupt vector 32 mask. */
  #define NVIC_PDD_TPM0_INTERRUPT_MASK        NVIC_ISER_SETENA17_MASK /**< Timer PWM module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_TPM1_INTERRUPT_MASK        NVIC_ISER_SETENA18_MASK /**< Timer PWM module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_TPM2_INTERRUPT_MASK        NVIC_ISER_SETENA19_MASK /**< Timer PWM module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_RTC_INTERRUPT_MASK         NVIC_ISER_SETENA20_MASK /**< real time clock alarm interrupt vector 36 mask. */
  #define NVIC_PDD_RTC_SECONDS_INTERRUPT_MASK NVIC_ISER_SETENA21_MASK /**< real time clock seconds interrupt vector 37 mask. */
  #define NVIC_PDD_PIT_INTERRUPT_MASK         NVIC_ISER_SETENA22_MASK /**< periodic interrupt timer all channels interrupt vector 38 mask. */
  #define NVIC_PDD_DAC0_INTERRUPT_MASK        NVIC_ISER_SETENA25_MASK /**< digital-to-analog converter 0 interrupt vector 41 mask. */
  #define NVIC_PDD_TSI0_INTERRUPT_MASK        NVIC_ISER_SETENA26_MASK /**< touch sensing input interrupt vector 42 mask. */
  #define NVIC_PDD_MCG_INTERRUPT_MASK         NVIC_ISER_SETENA27_MASK /**< multipurpose clock generator interrupt vector 43 mask. */
  #define NVIC_PDD_LPTMR0_INTERRUPT_MASK      NVIC_ISER_SETENA28_MASK /**< Low-Power Timer interrupt vector 44 mask. */
  #define NVIC_PDD_PORTA_INTERRUPT_MASK       NVIC_ISER_SETENA30_MASK /**< PORTA pin detect interrupt vector 46 mask. */
  #define NVIC_PDD_PORTC_PORTD_INTERRUPT_MASK NVIC_ISER_SETENA31_MASK /**< PORTC and PORTD pin detect interrupt vector 47 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR16_MASK    NVIC_ISER_SETENA0_MASK /**< DMA channel 0 transfer complete and error interrupt vector 16 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR17_MASK    NVIC_ISER_SETENA1_MASK /**< DMA channel 1 transfer complete and error interrupt vector 17 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR18_MASK    NVIC_ISER_SETENA2_MASK /**< DMA channel 2 transfer complete and error interrupt vector 18 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR19_MASK    NVIC_ISER_SETENA3_MASK /**< DMA channel 3 transfer complete and error interrupt vector 19 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR21_MASK    NVIC_ISER_SETENA5_MASK /**< FTFA command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR22_MASK    NVIC_ISER_SETENA6_MASK /**< low-voltage detect and low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR23_MASK    NVIC_ISER_SETENA7_MASK /**< low leakage wakeup interrupt vector 23 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR24_MASK    NVIC_ISER_SETENA8_MASK /**< inter-integrated circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR25_MASK    NVIC_ISER_SETENA9_MASK /**< inter-integrated circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR26_MASK    NVIC_ISER_SETENA10_MASK /**< serial peripheral interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR27_MASK    NVIC_ISER_SETENA11_MASK /**< serial peripheral interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR28_MASK    NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR29_MASK    NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR30_MASK    NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR31_MASK    NVIC_ISER_SETENA15_MASK /**< Analog-to-digital converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR32_MASK    NVIC_ISER_SETENA16_MASK /**< Comparator 0 interrupt vector 32 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR33_MASK    NVIC_ISER_SETENA17_MASK /**< Timer PWM module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR34_MASK    NVIC_ISER_SETENA18_MASK /**< Timer PWM module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR35_MASK    NVIC_ISER_SETENA19_MASK /**< Timer PWM module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR36_MASK    NVIC_ISER_SETENA20_MASK /**< real time clock alarm interrupt vector 36 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR37_MASK    NVIC_ISER_SETENA21_MASK /**< real time clock seconds interrupt vector 37 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR38_MASK    NVIC_ISER_SETENA22_MASK /**< periodic interrupt timer all channels interrupt vector 38 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR41_MASK    NVIC_ISER_SETENA25_MASK /**< digital-to-analog converter 0 interrupt vector 41 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR42_MASK    NVIC_ISER_SETENA26_MASK /**< touch sensing input interrupt vector 42 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR43_MASK    NVIC_ISER_SETENA27_MASK /**< multipurpose clock generator interrupt vector 43 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR44_MASK    NVIC_ISER_SETENA28_MASK /**< Low-Power Timer interrupt vector 44 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR46_MASK    NVIC_ISER_SETENA30_MASK /**< PORTA pin detect interrupt vector 46 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR47_MASK    NVIC_ISER_SETENA31_MASK /**< PORTC and PORTD pin detect interrupt vector 47 mask. */

#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/* Interrupts' mask */
  #define NVIC_PDD_FTMRE_INTERRUPT_MASK    NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_LVD_LLW_INTERRUPT_MASK  NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_IRQ_INTERRUPT_MASK      NVIC_ISER_SETENA7_MASK /**< External Interrupt interrupt vector 23 mask. */
  #define NVIC_PDD_I2C0_INTERRUPT_MASK     NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_I2C1_INTERRUPT_MASK     NVIC_ISER_SETENA9_MASK /**< Inter-Integrated Circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_SPI0_INTERRUPT_MASK     NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_SPI1_INTERRUPT_MASK     NVIC_ISER_SETENA11_MASK /**< Serial Peripheral Interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_UART0_INTERRUPT_MASK    NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_UART1_INTERRUPT_MASK    NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_UART2_INTERRUPT_MASK    NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_ADC0_INTERRUPT_MASK     NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_ACMP0_INTERRUPT_MASK    NVIC_ISER_SETENA16_MASK /**< Analog comparator 0 interrupt interrupt vector 32 mask. */
  #define NVIC_PDD_FTM0_INTERRUPT_MASK     NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_FTM1_INTERRUPT_MASK     NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_FTM2_INTERRUPT_MASK     NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_RTC_INTERRUPT_MASK      NVIC_ISER_SETENA20_MASK /**< Real-time counter interrupt vector 36 mask. */
  #define NVIC_PDD_ACMP1_INTERRUPT_MASK    NVIC_ISER_SETENA21_MASK /**< Analog comparator 1 interrupt interrupt vector 37 mask. */
  #define NVIC_PDD_PIT_CH0_INTERRUPT_MASK  NVIC_ISER_SETENA22_MASK /**< Periodic timer overflow channel 0 interrupt vector 38 mask. */
  #define NVIC_PDD_PIT_CH1_INTERRUPT_MASK  NVIC_ISER_SETENA23_MASK /**< Periodic timer overflow channel 1 interrupt vector 39 mask. */
  #define NVIC_PDD_KBI0_INTERRUPT_MASK     NVIC_ISER_SETENA24_MASK /**< Keyboard interrupt interrupt vector 40 mask. */
  #define NVIC_PDD_KBI1_INTERRUPT_MASK     NVIC_ISER_SETENA25_MASK /**< Keyboard interrupt interrupt vector 41 mask. */
  #define NVIC_PDD_ICS_INTERRUPT_MASK      NVIC_ISER_SETENA27_MASK /**< Clock loss of lock interrupt vector 43 mask. */
  #define NVIC_PDD_WDOG_EWM_INTERRUPT_MASK NVIC_ISER_SETENA28_MASK /**< WDOG interrupt vector 44 mask. */
  #define NVIC_PDD_PWT_INTERRUPT_MASK      NVIC_ISER_SETENA29_MASK /**< Pulse width timer interrupt vector 45 mask. */
  #define NVIC_PDD_MSCAN_RX_INTERRUPT_MASK NVIC_ISER_SETENA30_MASK /**< Freescale's Scalable Controller Area Network Rx interrupt vector 46 mask. */
  #define NVIC_PDD_MSCAN_TX_INTERRUPT_MASK NVIC_ISER_SETENA31_MASK /**< Freescale's Scalable Controller Area Network Tx and error interrupt vector 47 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR21_MASK NVIC_ISER_SETENA5_MASK /**< Command complete and read collision interrupt vector 21 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR22_MASK NVIC_ISER_SETENA6_MASK /**< Low-voltage detect, low-voltage warning interrupt vector 22 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR23_MASK NVIC_ISER_SETENA7_MASK /**< External Interrupt interrupt vector 23 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR24_MASK NVIC_ISER_SETENA8_MASK /**< Inter-Integrated Circuit 0 interrupt vector 24 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR25_MASK NVIC_ISER_SETENA9_MASK /**< Inter-Integrated Circuit 1 interrupt vector 25 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR26_MASK NVIC_ISER_SETENA10_MASK /**< Serial Peripheral Interface 0 interrupt vector 26 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR27_MASK NVIC_ISER_SETENA11_MASK /**< Serial Peripheral Interface 1 interrupt vector 27 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR28_MASK NVIC_ISER_SETENA12_MASK /**< UART0 status and error interrupt vector 28 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR29_MASK NVIC_ISER_SETENA13_MASK /**< UART1 status and error interrupt vector 29 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR30_MASK NVIC_ISER_SETENA14_MASK /**< UART2 status and error interrupt vector 30 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR31_MASK NVIC_ISER_SETENA15_MASK /**< Analog-to-Digital Converter 0 interrupt vector 31 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR32_MASK NVIC_ISER_SETENA16_MASK /**< Analog comparator 0 interrupt interrupt vector 32 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR33_MASK NVIC_ISER_SETENA17_MASK /**< FlexTimer Module 0 interrupt vector 33 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR34_MASK NVIC_ISER_SETENA18_MASK /**< FlexTimer Module 1 interrupt vector 34 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR35_MASK NVIC_ISER_SETENA19_MASK /**< FlexTimer Module 2 interrupt vector 35 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR36_MASK NVIC_ISER_SETENA20_MASK /**< Real-time counter interrupt vector 36 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR37_MASK NVIC_ISER_SETENA21_MASK /**< Analog comparator 1 interrupt interrupt vector 37 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR38_MASK NVIC_ISER_SETENA22_MASK /**< Periodic timer overflow channel 0 interrupt vector 38 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR39_MASK NVIC_ISER_SETENA23_MASK /**< Periodic timer overflow channel 1 interrupt vector 39 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR40_MASK NVIC_ISER_SETENA24_MASK /**< Keyboard interrupt interrupt vector 40 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR41_MASK NVIC_ISER_SETENA25_MASK /**< Keyboard interrupt interrupt vector 41 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR43_MASK NVIC_ISER_SETENA27_MASK /**< Clock loss of lock interrupt vector 43 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR44_MASK NVIC_ISER_SETENA28_MASK /**< WDOG interrupt vector 44 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR45_MASK NVIC_ISER_SETENA29_MASK /**< Pulse width timer interrupt vector 45 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR46_MASK NVIC_ISER_SETENA30_MASK /**< Freescale's Scalable Controller Area Network Rx interrupt vector 46 mask. */
  #define NVIC_PDD_INTERRUPT_VECTOR47_MASK NVIC_ISER_SETENA31_MASK /**< Freescale's Scalable Controller Area Network Tx and error interrupt vector 47 mask. */

#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- SetFtmrePriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Command complete and read collision
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtmrePriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetFtmrePriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,1U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetPmcPriority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Low-voltage detect, low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPmcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPmcPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the PMC controller low-voltage detect,
 * low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPmcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPmcPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,20U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetIrqPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the External Interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetIrqPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetIrqPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,1U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetI2C0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Inter-Integrated Circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,24U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetI2C1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Inter-Integrated Circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,25U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetSpi0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Serial Peripheral Interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,26U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetSpi1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Serial Peripheral Interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,27U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetUart0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART0 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,3U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
      (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART1 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,3U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART2 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart2Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,3U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetAdcPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetAdcPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,3U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetAcmp0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Analog comparator 0 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAcmp0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetAcmp0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
      (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetFtm0Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the FlexTimer module 0 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,42U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtm1Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the FlexTimer module 1 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,43U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtm2Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm2Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the FlexTimer module 2 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm2Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,44U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetRtcPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the real time clock alarm interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Real-time counter interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the real time clock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,46U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAcmp1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Analog comparator 1 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAcmp1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetAcmp1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,5U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetPitCh0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Periodic timer overflow channel 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitCh0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPitCh0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,5U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetPitCh1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Periodic timer overflow channel 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitCh1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPitCh1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,5U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetKbi0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetKbi0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetKbi0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,6U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
      (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetKbi1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetKbi1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetKbi1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,6U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetIcsPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Clock loss of lock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetIcsPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetIcsPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,6U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetWdogPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the WDOG interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetWdogPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
      (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetPwtPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Pulse width timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPwtPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPwtPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtmrePriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtmrePriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtmrePriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPmcPriority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Low-voltage detect, low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPmcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the PMC controller low-voltage
 * detect, low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPmcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,20U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetIrqPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the External Interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIrqPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIrqPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2C0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Inter-Integrated Circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetI2C0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,24U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetI2C1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Inter-Integrated Circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetI2C1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,25U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Serial Peripheral Interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetSpi0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,26U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Serial Peripheral Interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetSpi1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,27U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetUart0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART0 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0Priority(PeripheralBase) ( \
    (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART1 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART2 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetAdcPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdcPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetAcmp0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Analog comparator 0 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp0Priority(PeripheralBase) ( \
    (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtm0Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the FlexTimer module 0 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetFtm0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,42U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm1Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the FlexTimer module 1 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetFtm1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,43U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm2Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the FlexTimer module 2 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetFtm2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,44U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetRtcPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the real time clock alarm interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPriority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Real-time counter interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPriority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the real time clock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetRtcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,46U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAcmp1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Analog comparator 1 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp1Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Periodic timer overflow channel
 * 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh0Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Periodic timer overflow channel
 * 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh1Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi0Priority(PeripheralBase) ( \
    (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi1Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetIcsPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Clock loss of lock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIcsPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIcsPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetWdogPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the WDOG interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetWdogPriority(PeripheralBase) ( \
    (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPwtPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Pulse width timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPwtPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPwtPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the FTFA command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector21(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector21(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Command complete and read collision
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector21(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector21(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 5 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector21(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector21(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the low-voltage detect and low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector22(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector22(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Low-voltage detect, low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector22(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector22(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 6 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector22(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector22(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Low Leakage Wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector23(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector23(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector23(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector23(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the External Interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector23(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector23(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 7 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector23(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector23(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector24(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector24(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Inter-Integrated Circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector24(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector24(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 8 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector24(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector24(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,8U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector25(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector25(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Inter-Integrated Circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector25(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector25(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 9 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector25(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector25(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,9U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector26(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector26(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Serial Peripheral Interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector26(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector26(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 10 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector26(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector26(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,10U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector27(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector27(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Serial Peripheral Interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector27(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector27(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 11 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector27(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector27(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,11U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the UART0 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector28(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector28(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 12 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector28(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector28(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,12U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the UART1 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector29(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector29(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 13 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector29(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector29(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,13U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the UART2 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector30(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector30(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 14 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector30(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector30(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,14U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector31(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector31(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector31(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector31(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 15 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector31(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector31(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,15U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Analog-to-Digital Converter 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector32(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector32(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector32(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector32(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Analog comparator 0 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector32(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector32(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 0 - 15 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector32(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector32(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,16U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Timer PWM module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector33(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector33(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector33(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector33(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the MCM normal interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector33(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector33(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,17U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Timer PWM module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector34(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector34(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector34(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector34(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the FTFL command complete interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector34(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector34(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,18U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Timer PWM module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector35(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector35(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the FlexTimer Module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector35(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector35(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the FTFL read collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector35(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector35(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,19U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector36(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector36(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the real time clock alarm interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector36(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector36(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Real-time counter interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector36(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector36(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the PMC controller low-voltage detect,
 * low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector36(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector36(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,20U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector37(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector37(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the real time clock seconds interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector37(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector37(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Analog comparator 1 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector37(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector37(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector37(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector37(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,21U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the periodic interrupt timer all
 * channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector38(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector38(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Periodic timer overflow channel 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector38(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector38(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the single interrupt vector for  WDOG
 * and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector38(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector38(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,22U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector39(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector39(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Periodic timer overflow channel 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector39(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector39(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the randon number generator interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector39(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector39(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,23U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector40(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector40(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector40(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector40(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,24U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Digital-to-Analog Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector41(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector41(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the digital-to-analog converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector41(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector41(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector41(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector41(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector41(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector41(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,25U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Multipurpose Clock Generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector43(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector43(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector43(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector43(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Clock loss of lock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector43(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector43(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector43(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector43(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,27U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Sets the interrupt priority of the Low-Power Timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector44(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector44(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the WDOG interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector44(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector44(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the integrated interchip sound 0
 * transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector44(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector44(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,28U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Programmable Delay Block interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector45(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector45(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Pulse width timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector45(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector45(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the integrated interchip sound 0
 * receive interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector45(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector45(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,29U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the FTFA command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector21(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector21(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 5 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector21(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,5U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the low-voltage detect and
 * low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector22(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Low-voltage detect, low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector22(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 6 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector22(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,6U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Low Leakage Wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector23(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector23(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the External Interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector23(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 7 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector23(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,7U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Inter-Integrated Circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 8 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector24(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,8U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector25(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Inter-Integrated Circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector25(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 9 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector25(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,9U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector26(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Serial Peripheral Interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector26(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 10 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector26(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,10U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector27(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Serial Peripheral Interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector27(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,2U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 11 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector27(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,11U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the UART0 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector28(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 12 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector28(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,12U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the UART1 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector29(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 13 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector29(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,13U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the UART2 status and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector30(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 14 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector30(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,14U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector31(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector31(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 15 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector31(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,15U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Analog-to-Digital Converter 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Analog comparator 0 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 0 - 15 error
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector32(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,16U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Timer PWM module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector33(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector33(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the MCM normal interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector33(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,17U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Timer PWM module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector34(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector34(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the FTFL command complete interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector34(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,18U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Timer PWM module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector35(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the FlexTimer Module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector35(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the FTFL read collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector35(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,19U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the real time clock alarm interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Real-time counter interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the PMC controller low-voltage
 * detect, low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector36(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,20U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector37(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the real time clock seconds
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector37(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Analog comparator 1 interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector37(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector37(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,21U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the periodic interrupt timer all
 * channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector38(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Periodic timer overflow channel
 * 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector38(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the single interrupt vector for
 * WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector38(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,22U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector39(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Periodic timer overflow channel
 * 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector39(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the randon number generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector39(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,23U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector40(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector40(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,24U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Digital-to-Analog Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector41(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the digital-to-analog converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector41(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Keyboard interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector41(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the inter-integrated circuit 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector41(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,25U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Multipurpose Clock Generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector43(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector43(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Clock loss of lock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector43(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector43(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,27U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns the interrupt priority of the Low-Power Timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the WDOG interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the integrated interchip sound 0
 * transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector44(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,28U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Programmable Delay Block
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector45(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Pulse width timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector45(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the integrated interchip sound 0
 * receive interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector45(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,29U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtmrePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtmrePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtmrePending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND5_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPmcPending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Low-voltage detect, low-voltage warning
 * IRQ is pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND6_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the PMC controller low-voltage detect,
 * low-voltage warning IRQ is pending for vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 20U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetIrqPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the External Interrupt IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIrqPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIrqPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2C0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND8_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 0 IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND8_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * pending for vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 24U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetI2C1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND9_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 1 IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND9_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 25U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND10_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 0 IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND10_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * pending for vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 26U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND11_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 1 IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND11_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 27U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetUart0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 status and error IRQ is pending
 * for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND12_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 status and error IRQ is pending
 * for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND13_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 status and error IRQ is pending
 * for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND14_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetAdcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdcPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND15_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetAcmp0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog comparator 0 interrupt IRQ is
 * pending for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtm0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 0 IRQ is pending for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND17_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 0 fault, overflow and
 * channels IRQ is pending for vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 10U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm1Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 1 IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND18_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 1 fault, overflow and
 * channels IRQ is pending for vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 11U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm2Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 2 IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND19_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 2 fault, overflow and
 * channels IRQ is pending for vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 12U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetRtcPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock alarm IRQ is pending for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Real-time counter IRQ is pending for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the real time clock IRQ is pending for
 * vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 14U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAcmp1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog comparator 1 interrupt IRQ is
 * pending for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 0 IRQ is
 * pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND22_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 1 IRQ is
 * pending for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND23_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is pending for
 * vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND24_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is pending for
 * vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetIcsPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Clock loss of lock IRQ is pending for
 * vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIcsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIcsPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetWdogPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the WDOG IRQ is pending for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetWdogPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND28_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPwtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Pulse width timer IRQ is pending for
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPwtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPwtPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND29_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- SetFtmrePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Command complete and read collision interrupt vector number 21
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtmrePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetFtmrePending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND5_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetPmcPending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Low-voltage detect, low-voltage warning interrupt vector number
 * 22 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPmcPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPmcPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetIrqPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces External Interrupt interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetIrqPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetIrqPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND7_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetI2C0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces inter-integrated circuit 0 interrupt vector number 24 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Inter-Integrated Circuit 0 interrupt vector number 24 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces inter-integrated circuit 0 interrupt vector number 40 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetI2C1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces inter-integrated circuit 1 interrupt vector number 25 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Inter-Integrated Circuit 1 interrupt vector number 25 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces inter-integrated circuit 1 interrupt vector number 41 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetI2C1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetSpi0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces serial peripheral interface 0 interrupt vector number 26 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Serial Peripheral Interface 0 interrupt vector number 26 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces serial peripheral interface 0 interrupt vector number 42 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetSpi1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces serial peripheral interface 1 interrupt vector number 27 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Serial Peripheral Interface 1 interrupt vector number 27 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces serial peripheral interface 1 interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetSpi1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetUart0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART0 status and error interrupt vector number 28 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND12_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART1 status and error interrupt vector number 29 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND13_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART2 status and error interrupt vector number 30 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart2Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND14_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetAdcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Analog-to-Digital Converter 0 interrupt vector number 31 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetAdcPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND15_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetAcmp0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Analog comparator 0 interrupt interrupt vector number 32 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAcmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetAcmp0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetFtm0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 0 interrupt vector number 33 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtm1Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 1 interrupt vector number 34 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtm2Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 2 interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm2Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtm2Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetRtcPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces real time clock alarm interrupt vector number 36 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Real-time counter interrupt vector number 36 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces real time clock interrupt vector number 62 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAcmp1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Analog comparator 1 interrupt interrupt vector number 37 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAcmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetAcmp1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND21_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetPitCh0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Periodic timer overflow channel 0 interrupt vector number 38
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitCh0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPitCh0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetPitCh1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Periodic timer overflow channel 1 interrupt vector number 39
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitCh1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPitCh1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND23_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetKbi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Keyboard interrupt interrupt vector number 40 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetKbi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetKbi0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND24_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetKbi1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Keyboard interrupt interrupt vector number 41 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetKbi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetKbi1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND25_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetIcsPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Clock loss of lock interrupt vector number 43 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetIcsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetIcsPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND27_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetWdogPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces WDOG interrupt vector number 44 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetWdogPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND28_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetPwtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Pulse width timer interrupt vector number 45 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPwtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPwtPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND29_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearFtmrePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Command complete and read collision
 * interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtmrePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearFtmrePending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND5_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearPmcPending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Low-voltage detect, low-voltage
 * warning interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPmcPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the PMC controller low-voltage detect,
 * low-voltage warning interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPmcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPmcPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearIrqPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the External Interrupt interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearIrqPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearIrqPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND7_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearI2C0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the inter-integrated circuit 0
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Inter-Integrated Circuit 0
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the inter-integrated circuit 0
 * interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearI2C1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the inter-integrated circuit 1
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Inter-Integrated Circuit 1
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the inter-integrated circuit 1
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2C1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearI2C1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearSpi0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the serial peripheral interface 0
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Serial Peripheral Interface 0
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the serial peripheral interface 0
 * interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearSpi1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the serial peripheral interface 1
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Serial Peripheral Interface 1
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the serial peripheral interface 1
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSpi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearSpi1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearUart0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART0 status and error interrupt
 * vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND12_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART1 status and error interrupt
 * vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND13_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART2 status and error interrupt
 * vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart2Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND14_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearAdcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Analog-to-Digital Converter 0
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAdcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearAdcPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND15_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearAcmp0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Analog comparator 0 interrupt
 * interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAcmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearAcmp0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearFtm0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 0 interrupt vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the FlexTimer module 0 fault, overflow
 * and channels interrupt vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearFtm1Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 1 interrupt vector
 * number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the FlexTimer module 1 fault, overflow
 * and channels interrupt vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearFtm2Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 2 interrupt vector
 * number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm2Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the FlexTimer module 2 fault, overflow
 * and channels interrupt vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtm2Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearRtcPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the real time clock alarm interrupt
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearRtcPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Real-time counter interrupt vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearRtcPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the real time clock interrupt vector
 * number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRtcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearRtcPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearAcmp1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Analog comparator 1 interrupt
 * interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAcmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearAcmp1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND21_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearPitCh0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Periodic timer overflow channel 0
 * interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPitCh0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPitCh0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearPitCh1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Periodic timer overflow channel 1
 * interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPitCh1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPitCh1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND23_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearKbi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Keyboard interrupt interrupt vector
 * number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearKbi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearKbi0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND24_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearKbi1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Keyboard interrupt interrupt vector
 * number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearKbi1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearKbi1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND25_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearIcsPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Clock loss of lock interrupt vector
 * number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearIcsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearIcsPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND27_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearWdogPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearWdogPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearWdogPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND28_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearPwtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Pulse width timer interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPwtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPwtPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND29_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetFtmreEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtmreEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtmreEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA5_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPmcEnabled
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Low-voltage detect, low-voltage warning
 * IRQ is enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPmcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA6_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the PMC controller low-voltage detect,
 * low-voltage warning IRQ is enabled for vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPmcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPmcEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x100000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetIrqEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the External Interrupt IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIrqEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIrqEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2C0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA8_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 0 IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA8_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * enabled for vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetI2C1Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA9_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 1 IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA9_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2C1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetI2C1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA10_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 0 IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA10_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * enabled for vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetSpi1Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA11_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 1 IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA11_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSpi1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetSpi1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetUart0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 status and error IRQ is enabled
 * for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA12_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 status and error IRQ is enabled
 * for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA13_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 status and error IRQ is enabled
 * for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA14_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetAdcEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdcEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA15_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetAcmp0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog comparator 0 interrupt IRQ is
 * enabled for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtm0Enabled
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 0 IRQ is enabled for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA17_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 0 fault, overflow and
 * channels IRQ is enabled for vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x400U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm1Enabled
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 1 IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA18_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 1 fault, overflow and
 * channels IRQ is enabled for vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x800U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtm2Enabled
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 2 IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA19_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FlexTimer module 2 fault, overflow and
 * channels IRQ is enabled for vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtm2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtm2Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x1000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetRtcEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock alarm IRQ is enabled for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Real-time counter IRQ is enabled for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the real time clock IRQ is enabled for
 * vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAcmp1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog comparator 1 interrupt IRQ is
 * enabled for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAcmp1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAcmp1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 0 IRQ is
 * enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA22_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPitCh1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 1 IRQ is
 * enabled for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitCh1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitCh1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA23_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is enabled for
 * vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA24_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetKbi1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is enabled for
 * vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetKbi1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetKbi1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetIcsEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Clock loss of lock IRQ is enabled for
 * vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetIcsEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetIcsEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetWdogEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the WDOG IRQ is enabled for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetWdogEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA28_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPwtEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Pulse width timer IRQ is enabled for
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPwtEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPwtEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA29_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- EnableFtmre
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtmre(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableFtmre(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA5_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnablePmc
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Low-voltage detect, low-voltage warning interrupt vector
 * number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePmc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePmc(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePmc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePmc(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableIrq
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the External Interrupt interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableIrq(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableIrq(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA7_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableI2C0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the inter-integrated circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Inter-Integrated Circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the inter-integrated circuit 0 interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableI2C1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the inter-integrated circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Inter-Integrated Circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the inter-integrated circuit 1 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableI2C1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableSpi0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the serial peripheral interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Serial Peripheral Interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the serial peripheral interface 0 interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableSpi1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the serial peripheral interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Serial Peripheral Interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the serial peripheral interface 1 interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableSpi1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableUart0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART0 status and error interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA12_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART1 status and error interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA13_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart2
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART2 status and error interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart2(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA14_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableAdc
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAdc(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableAdc(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA15_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableAcmp0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Analog comparator 0 interrupt interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAcmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableAcmp0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableFtm0
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableFtm1
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableFtm2
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm2(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtm2(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableRtc
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the real time clock alarm interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableRtc(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Real-time counter interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableRtc(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the real time clock interrupt vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableRtc(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableAcmp1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Analog comparator 1 interrupt interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAcmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableAcmp1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA21_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnablePitCh0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Periodic timer overflow channel 0 interrupt vector number
 * 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePitCh0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePitCh0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnablePitCh1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Periodic timer overflow channel 1 interrupt vector number
 * 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePitCh1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePitCh1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA23_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableKbi0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Keyboard interrupt interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableKbi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableKbi0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA24_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableKbi1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Keyboard interrupt interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableKbi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableKbi1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA25_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableIcs
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Clock loss of lock interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableIcs(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableIcs(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA27_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableWdog
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableWdog(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableWdog(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA28_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnablePwt
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Pulse width timer interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePwt(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePwt(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA29_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableFtmre
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtmre(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableFtmre(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA5_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisablePmc
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Low-voltage detect, low-voltage warning interrupt vector
 * number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePmc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePmc(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePmc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePmc(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableIrq
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the External Interrupt interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableIrq(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableIrq(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA7_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableI2C0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the inter-integrated circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Inter-Integrated Circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the inter-integrated circuit 0 interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableI2C1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the inter-integrated circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Inter-Integrated Circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the inter-integrated circuit 1 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2C1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableI2C1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableSpi0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the serial peripheral interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Serial Peripheral Interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the serial peripheral interface 0 interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableSpi1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the serial peripheral interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Serial Peripheral Interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the serial peripheral interface 1 interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSpi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableSpi1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableUart0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART0 status and error interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA12_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART1 status and error interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA13_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart2
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART2 status and error interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart2(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA14_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableAdc
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAdc(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableAdc(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA15_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableAcmp0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Analog comparator 0 interrupt interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAcmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableAcmp0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableFtm0
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableFtm1
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableFtm2
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm2(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtm2(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableRtc
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the real time clock alarm interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableRtc(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Real-time counter interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableRtc(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the real time clock interrupt vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRtc(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableRtc(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableAcmp1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Analog comparator 1 interrupt interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAcmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableAcmp1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA21_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisablePitCh0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Periodic timer overflow channel 0 interrupt vector number
 * 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePitCh0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePitCh0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisablePitCh1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Periodic timer overflow channel 1 interrupt vector number
 * 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePitCh1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePitCh1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA23_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableKbi0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Keyboard interrupt interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableKbi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableKbi0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA24_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableKbi1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Keyboard interrupt interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableKbi1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableKbi1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA25_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableIcs
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Clock loss of lock interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableIcs(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableIcs(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA27_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableWdog
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableWdog(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableWdog(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA28_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisablePwt
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Pulse width timer interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePwt(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePwt(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA29_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the FTFA command complete and read collision
 * IRQ is pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND5_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND5_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 5 transfer complete IRQ is
 * pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 5U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low-voltage detect and low-voltage
 * warning IRQ is pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND6_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Low-voltage detect, low-voltage warning
 * IRQ is pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND6_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 6 transfer complete IRQ is
 * pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 6U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Low Leakage Wakeup IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the External Interrupt IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 7 transfer complete IRQ is
 * pending for vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 7U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND8_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 0 IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND8_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 8 transfer complete IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 8U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND9_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 1 IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND9_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 9 transfer complete IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 9U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND10_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 0 IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND10_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 10 transfer complete IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 10U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND11_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 1 IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND11_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 11 transfer complete IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 11U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART0 status and error IRQ is pending
 * for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector28(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND12_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 12 transfer complete IRQ is
 * pending for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector28(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 12U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART1 status and error IRQ is pending
 * for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector29(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND13_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 13 transfer complete IRQ is
 * pending for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector29(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 13U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART2 status and error IRQ is pending
 * for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector30(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND14_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 14 transfer complete IRQ is
 * pending for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector30(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 14U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Analog-to-digital converter 0 IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND15_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND15_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 15 transfer complete IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 15U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 1 IRQ is
 * pending for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is pending for vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog comparator 0 interrupt IRQ is
 * pending for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 - 15 error IRQ is pending
 * for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 16U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 0 IRQ is pending for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND17_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 0 IRQ is pending for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND17_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the MCM normal IRQ is pending for vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 17U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 1 IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND18_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 1 IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND18_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FTFL command complete IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 18U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 2 IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND19_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 2 IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND19_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FTFL read collision IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 19U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is pending for vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock alarm IRQ is pending for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Real-time counter IRQ is pending for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the PMC controller low-voltage detect,
 * low-voltage warning IRQ is pending for vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 20U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 1 IRQ is pending for vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is pending
 * for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog comparator 1 interrupt IRQ is
 * pending for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is pending for
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 21U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the periodic interrupt timer all channels
 * IRQ is pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND22_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 0 IRQ is
 * pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND22_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the single interrupt vector for  WDOG and
 * EWM IRQ is pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 22U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the WDOG and EWM IRQ is pending for vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND23_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 1 IRQ is
 * pending for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND23_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the randon number generator IRQ is pending
 * for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 23U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is pending for
 * vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector40(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND24_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * pending for vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector40(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 24U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Digital-to-Analog Converter 0 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the digital-to-analog converter 0 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is pending for
 * vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 25U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Multipurpose Clock Generator IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Clock loss of lock IRQ is pending for
 * vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 27U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns non-zero value if the Low-Power Timer IRQ is pending for
 * vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND28_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the WDOG IRQ is pending for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND28_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the integrated interchip sound 0 transmit
 * IRQ is pending for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 28U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Programmable Delay Block IRQ is pending
 * for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND29_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Pulse width timer IRQ is pending for
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND29_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the integrated interchip sound 0 receive IRQ
 * is pending for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 29U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces FTFA command complete and read collision interrupt vector
 * number 21 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector21(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND5_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Command complete and read collision interrupt vector number 21
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector21(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND5_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 5 transfer complete interrupt vector number 21 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector21(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x20U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces low-voltage detect and low-voltage warning interrupt vector
 * number 22 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector22(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND6_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Low-voltage detect, low-voltage warning interrupt vector number
 * 22 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector22(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 6 transfer complete interrupt vector number 22 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector22(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x40U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Low Leakage Wakeup interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector23(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces low leakage wakeup interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector23(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND7_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces External Interrupt interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector23(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 7 transfer complete interrupt vector number 23 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector23(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces inter-integrated circuit 0 interrupt vector number 24 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector24(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Inter-Integrated Circuit 0 interrupt vector number 24 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector24(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 8 transfer complete interrupt vector number 24 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector24(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces inter-integrated circuit 1 interrupt vector number 25 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector25(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Inter-Integrated Circuit 1 interrupt vector number 25 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector25(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 9 transfer complete interrupt vector number 25 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector25(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces serial peripheral interface 0 interrupt vector number 26 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector26(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Serial Peripheral Interface 0 interrupt vector number 26 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector26(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 10 transfer complete interrupt vector number 26
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector26(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces serial peripheral interface 1 interrupt vector number 27 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector27(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Serial Peripheral Interface 1 interrupt vector number 27 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector27(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 11 transfer complete interrupt vector number 27
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector27(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces UART0 status and error interrupt vector number 28 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector28(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND12_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 12 transfer complete interrupt vector number 28
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector28(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces UART1 status and error interrupt vector number 29 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector29(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND13_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 13 transfer complete interrupt vector number 29
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector29(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x2000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces UART2 status and error interrupt vector number 30 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector30(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND14_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 14 transfer complete interrupt vector number 30
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector30(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces Analog-to-digital converter 0 interrupt vector number 31 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector31(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND15_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Analog-to-Digital Converter 0 interrupt vector number 31 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector31(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 15 transfer complete interrupt vector number 31
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector31(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Analog-to-Digital Converter 1 interrupt vector number 32 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector32(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND16_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces Comparator 0 interrupt vector number 32 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector32(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND16_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Analog comparator 0 interrupt interrupt vector number 32 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector32(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 0 - 15 error interrupt vector number 32 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector32(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces Timer PWM module 0 interrupt vector number 33 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector33(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND17_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 0 interrupt vector number 33 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector33(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces MCM normal interrupt vector number 33 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector33(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x20000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces Timer PWM module 1 interrupt vector number 34 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector34(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND18_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 1 interrupt vector number 34 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector34(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces FTFL command complete interrupt vector number 34 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector34(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x40000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces Timer PWM module 2 interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector35(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND19_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces FlexTimer Module 2 interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector35(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces FTFL read collision interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector35(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x80000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Comparator 0 interrupt vector number 36 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector36(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces real time clock alarm interrupt vector number 36 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector36(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Real-time counter interrupt vector number 36 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector36(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector36(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Comparator 1 interrupt vector number 37 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector37(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND21_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces real time clock seconds interrupt vector number 37 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector37(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND21_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Analog comparator 1 interrupt interrupt vector number 37 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector37(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces low leakage wakeup interrupt vector number 37 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector37(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces periodic interrupt timer all channels interrupt vector number
 * 38 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector38(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND22_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Periodic timer overflow channel 0 interrupt vector number 38
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector38(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND22_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces single interrupt vector for  WDOG and EWM interrupt vector
 * number 38 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector38(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces WDOG and EWM interrupt vector number 39 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector39(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND23_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Periodic timer overflow channel 1 interrupt vector number 39
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector39(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces randon number generator interrupt vector number 39 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector39(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x800000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Keyboard interrupt interrupt vector number 40 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector40(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND24_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces inter-integrated circuit 0 interrupt vector number 40 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector40(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Digital-to-Analog Converter 0 interrupt vector number 41 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector41(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND25_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces digital-to-analog converter 0 interrupt vector number 41 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector41(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND25_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Keyboard interrupt interrupt vector number 41 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector41(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND25_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces inter-integrated circuit 1 interrupt vector number 41 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector41(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Multipurpose Clock Generator interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector43(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces multipurpose clock generator interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector43(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND27_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Clock loss of lock interrupt vector number 43 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector43(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces serial peripheral interface 1 interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector43(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Forces Low-Power Timer interrupt vector number 44 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector44(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND28_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces WDOG interrupt vector number 44 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector44(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces integrated interchip sound 0 transmit interrupt vector number
 * 44 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector44(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x10000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Programmable Delay Block interrupt vector number 45 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector45(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND29_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Pulse width timer interrupt vector number 45 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector45(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces integrated interchip sound 0 receive interrupt vector number 45
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector45(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x20000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the FTFA command complete and read
 * collision interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector21(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND5_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Command complete and read collision
 * interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector21(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND5_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 5 transfer complete
 * interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector21(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x20U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the low-voltage detect and low-voltage
 * warning interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector22(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND6_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Low-voltage detect, low-voltage
 * warning interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector22(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 6 transfer complete
 * interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector22(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x40U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Low Leakage Wakeup interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector23(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the low leakage wakeup interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector23(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND7_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the External Interrupt interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector23(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 7 transfer complete
 * interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector23(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the inter-integrated circuit 0
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector24(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Inter-Integrated Circuit 0
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector24(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 8 transfer complete
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector24(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the inter-integrated circuit 1
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector25(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Inter-Integrated Circuit 1
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector25(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 9 transfer complete
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector25(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the serial peripheral interface 0
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector26(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Serial Peripheral Interface 0
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector26(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 10 transfer complete
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector26(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the serial peripheral interface 1
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector27(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Serial Peripheral Interface 1
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector27(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 11 transfer complete
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector27(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the UART0 status and error interrupt
 * vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector28(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND12_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 12 transfer complete
 * interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector28(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the UART1 status and error interrupt
 * vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector29(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND13_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 13 transfer complete
 * interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector29(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x2000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the UART2 status and error interrupt
 * vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector30(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND14_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 14 transfer complete
 * interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector30(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Analog-to-digital converter 0
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector31(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND15_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Analog-to-Digital Converter 0
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector31(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 15 transfer complete
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector31(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Analog-to-Digital Converter 1
 * interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector32(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND16_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Comparator 0 interrupt vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector32(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND16_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Analog comparator 0 interrupt
 * interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector32(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 0 - 15 error interrupt
 * vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector32(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Timer PWM module 0 interrupt vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector33(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND17_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 0 interrupt vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector33(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the MCM normal interrupt vector number
 * 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector33(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x20000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Timer PWM module 1 interrupt vector
 * number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector34(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND18_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 1 interrupt vector
 * number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector34(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the FTFL command complete interrupt
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector34(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x40000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Timer PWM module 2 interrupt vector
 * number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector35(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND19_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the FlexTimer Module 2 interrupt vector
 * number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector35(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the FTFL read collision interrupt
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector35(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x80000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Comparator 0 interrupt vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector36(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the real time clock alarm interrupt
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector36(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Real-time counter interrupt vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector36(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the PMC controller low-voltage detect,
 * low-voltage warning interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector36(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Comparator 1 interrupt vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector37(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND21_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the real time clock seconds interrupt
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector37(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND21_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Analog comparator 1 interrupt
 * interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector37(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the low leakage wakeup interrupt vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector37(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the periodic interrupt timer all
 * channels interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector38(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND22_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Periodic timer overflow channel 0
 * interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector38(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND22_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the single interrupt vector for  WDOG
 * and EWM interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector38(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the WDOG and EWM interrupt vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector39(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND23_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Periodic timer overflow channel 1
 * interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector39(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the randon number generator interrupt
 * vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector39(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x800000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Keyboard interrupt interrupt vector
 * number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector40(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND24_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the inter-integrated circuit 0
 * interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector40(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Digital-to-Analog Converter 0
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector41(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND25_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the digital-to-analog converter 0
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector41(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND25_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Keyboard interrupt interrupt vector
 * number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector41(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND25_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the inter-integrated circuit 1
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector41(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Multipurpose Clock Generator
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector43(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the multipurpose clock generator
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector43(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND27_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Clock loss of lock interrupt vector
 * number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector43(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the serial peripheral interface 1
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector43(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Removes the pending state from the Low-Power Timer interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector44(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND28_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector44(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the integrated interchip sound 0
 * transmit interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector44(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x10000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Programmable Delay Block interrupt
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector45(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND29_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Pulse width timer interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector45(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the integrated interchip sound 0
 * receive interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector45(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x20000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the FTFA command complete and read collision
 * IRQ is enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA5_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA5_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 5 transfer complete IRQ is
 * enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector21(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low-voltage detect and low-voltage
 * warning IRQ is enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA6_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Low-voltage detect, low-voltage warning
 * IRQ is enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA6_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 6 transfer complete IRQ is
 * enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector22(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x40U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Low Leakage Wakeup IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the External Interrupt IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 7 transfer complete IRQ is
 * enabled for vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector23(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA8_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 0 IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA8_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 8 transfer complete IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector24(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x100U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA9_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Inter-Integrated Circuit 1 IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA9_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 9 transfer complete IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector25(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x200U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA10_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 0 IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA10_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 10 transfer complete IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector26(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x400U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA11_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Serial Peripheral Interface 1 IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA11_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 11 transfer complete IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector27(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x800U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART0 status and error IRQ is enabled
 * for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector28(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA12_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 12 transfer complete IRQ is
 * enabled for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector28(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART1 status and error IRQ is enabled
 * for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector29(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA13_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 13 transfer complete IRQ is
 * enabled for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector29(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the UART2 status and error IRQ is enabled
 * for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector30(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA14_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 14 transfer complete IRQ is
 * enabled for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector30(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Analog-to-digital converter 0 IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA15_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA15_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 15 transfer complete IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector31(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 1 IRQ is
 * enabled for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is enabled for vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog comparator 0 interrupt IRQ is
 * enabled for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 - 15 error IRQ is enabled
 * for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector32(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 0 IRQ is enabled for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA17_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 0 IRQ is enabled for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA17_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the MCM normal IRQ is enabled for vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector33(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 1 IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA18_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 1 IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA18_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FTFL command complete IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector34(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x40000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Timer PWM module 2 IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA19_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the FlexTimer Module 2 IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA19_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the FTFL read collision IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector35(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is enabled for vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock alarm IRQ is enabled for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Real-time counter IRQ is enabled for
 * vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the PMC controller low-voltage detect,
 * low-voltage warning IRQ is enabled for vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector36(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x100000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 1 IRQ is enabled for vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is enabled
 * for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Analog comparator 1 interrupt IRQ is
 * enabled for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is enabled for
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector37(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x200000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the periodic interrupt timer all channels
 * IRQ is enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA22_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 0 IRQ is
 * enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA22_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the single interrupt vector for  WDOG and
 * EWM IRQ is enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector38(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x400000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the WDOG and EWM IRQ is enabled for vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA23_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Periodic timer overflow channel 1 IRQ is
 * enabled for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA23_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the randon number generator IRQ is enabled
 * for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector39(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x800000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is enabled for
 * vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector40(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA24_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 0 IRQ is
 * enabled for vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector40(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Digital-to-Analog Converter 0 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the digital-to-analog converter 0 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Keyboard interrupt IRQ is enabled for
 * vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the inter-integrated circuit 1 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector41(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Multipurpose Clock Generator IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Clock loss of lock IRQ is enabled for
 * vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 1 IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector43(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns non-zero value if the Low-Power Timer IRQ is enabled for
 * vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA28_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the WDOG IRQ is enabled for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA28_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the integrated interchip sound 0 transmit
 * IRQ is enabled for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector44(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Programmable Delay Block IRQ is enabled
 * for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA29_MASK) \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Pulse width timer IRQ is enabled for
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA29_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the integrated interchip sound 0 receive IRQ
 * is enabled for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector45(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the FTFA command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector21(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA5_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector21(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA5_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 5 transfer complete interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector21(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x20U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the low-voltage detect and low-voltage warning interrupt
 * vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector22(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA6_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Low-voltage detect, low-voltage warning interrupt vector
 * number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector22(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 6 transfer complete interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector22(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x40U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Low Leakage Wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector23(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the low leakage wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector23(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA7_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the External Interrupt interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector23(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 7 transfer complete interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector23(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the inter-integrated circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector24(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Inter-Integrated Circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector24(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 8 transfer complete interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector24(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the inter-integrated circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector25(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Inter-Integrated Circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector25(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 9 transfer complete interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector25(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the serial peripheral interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector26(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Serial Peripheral Interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector26(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 10 transfer complete interrupt vector number
 * 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector26(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the serial peripheral interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector27(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Serial Peripheral Interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector27(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 11 transfer complete interrupt vector number
 * 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector27(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the UART0 status and error interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector28(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA12_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 12 transfer complete interrupt vector number
 * 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector28(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the UART1 status and error interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector29(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA13_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 13 transfer complete interrupt vector number
 * 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector29(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x2000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the UART2 status and error interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector30(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA14_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 14 transfer complete interrupt vector number
 * 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector30(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Analog-to-digital converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector31(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA15_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector31(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 15 transfer complete interrupt vector number
 * 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector31(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Analog-to-Digital Converter 1 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector32(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA16_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Comparator 0 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector32(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA16_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Analog comparator 0 interrupt interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector32(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 0 - 15 error interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector32(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Timer PWM module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector33(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA17_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector33(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the MCM normal interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector33(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x20000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Timer PWM module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector34(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA18_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector34(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the FTFL command complete interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector34(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x40000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Timer PWM module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector35(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA19_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the FlexTimer Module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector35(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the FTFL read collision interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector35(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x80000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Comparator 0 interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector36(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the real time clock alarm interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector36(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Real-time counter interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector36(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector36(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Comparator 1 interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector37(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA21_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the real time clock seconds interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector37(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA21_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Analog comparator 1 interrupt interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector37(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the low leakage wakeup interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector37(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the periodic interrupt timer all channels interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector38(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA22_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Periodic timer overflow channel 0 interrupt vector number
 * 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector38(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA22_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the single interrupt vector for  WDOG and EWM interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector38(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the WDOG and EWM interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector39(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA23_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Periodic timer overflow channel 1 interrupt vector number
 * 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector39(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the randon number generator interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector39(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x800000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Keyboard interrupt interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector40(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA24_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the inter-integrated circuit 0 interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector40(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Digital-to-Analog Converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector41(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA25_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the digital-to-analog converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector41(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA25_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Keyboard interrupt interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector41(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA25_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the inter-integrated circuit 1 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector41(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Multipurpose Clock Generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector43(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the multipurpose clock generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector43(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA27_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Clock loss of lock interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector43(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the serial peripheral interface 1 interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector43(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Enables the Low-Power Timer interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector44(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA28_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector44(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the integrated interchip sound 0 transmit interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector44(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x10000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Programmable Delay Block interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector45(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA29_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Pulse width timer interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector45(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the integrated interchip sound 0 receive interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector45(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x20000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector21
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the FTFA command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector21(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA5_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector21(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA5_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 5 transfer complete interrupt vector number
 * 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector21(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector21(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x20U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector22
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the low-voltage detect and low-voltage warning interrupt
 * vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector22(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA6_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Low-voltage detect, low-voltage warning interrupt vector
 * number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector22(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA6_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 6 transfer complete interrupt vector number
 * 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector22(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector22(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x40U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector23
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Low Leakage Wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector23(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the low leakage wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector23(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA7_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the External Interrupt interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector23(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 7 transfer complete interrupt vector number
 * 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector23(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector23(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector24
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the inter-integrated circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector24(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA8_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Inter-Integrated Circuit 0 interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector24(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA8_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 8 transfer complete interrupt vector number
 * 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector24(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector24(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector25
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the inter-integrated circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector25(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA9_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Inter-Integrated Circuit 1 interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector25(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA9_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 9 transfer complete interrupt vector number
 * 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector25(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector25(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector26
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the serial peripheral interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector26(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA10_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Serial Peripheral Interface 0 interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector26(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA10_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 10 transfer complete interrupt vector number
 * 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector26(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector26(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x400U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector27
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the serial peripheral interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector27(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA11_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Serial Peripheral Interface 1 interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector27(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA11_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 11 transfer complete interrupt vector number
 * 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector27(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector27(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x800U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector28
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the UART0 status and error interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector28(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA12_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 12 transfer complete interrupt vector number
 * 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector28(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector28(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x1000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector29
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the UART1 status and error interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector29(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA13_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 13 transfer complete interrupt vector number
 * 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector29(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector29(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x2000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector30
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKW01Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the UART2 status and error interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector30(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA14_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 14 transfer complete interrupt vector number
 * 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector30(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector30(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x4000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector31
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Analog-to-digital converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector31(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA15_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector31(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 15 transfer complete interrupt vector number
 * 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector31(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector31(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector32
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Analog-to-Digital Converter 1 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector32(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA16_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Comparator 0 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector32(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA16_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Analog comparator 0 interrupt interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector32(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 0 - 15 error interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector32(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector32(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector33
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Timer PWM module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector33(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA17_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector33(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA17_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the MCM normal interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector33(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector33(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x20000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector34
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Timer PWM module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector34(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA18_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector34(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA18_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the FTFL command complete interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector34(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector34(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x40000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector35
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Timer PWM module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector35(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA19_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_MKV10Z7)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the FlexTimer Module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector35(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA19_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the FTFL read collision interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector35(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector35(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x80000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector36
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Comparator 0 interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector36(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the real time clock alarm interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector36(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Real-time counter interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector36(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the PMC controller low-voltage detect, low-voltage warning
 * interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector36(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector36(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector37
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Comparator 1 interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector37(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA21_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the real time clock seconds interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector37(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA21_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Analog comparator 1 interrupt interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector37(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the low leakage wakeup interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector37(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector37(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector38
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the periodic interrupt timer all channels interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector38(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA22_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Periodic timer overflow channel 0 interrupt vector number
 * 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector38(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA22_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the single interrupt vector for  WDOG and EWM interrupt
 * vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector38(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector38(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector39
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the WDOG and EWM interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector39(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA23_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Periodic timer overflow channel 1 interrupt vector number
 * 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector39(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the randon number generator interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector39(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector39(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x800000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector40
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Keyboard interrupt interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector40(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA24_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the inter-integrated circuit 0 interrupt vector number 40.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector40(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector40(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x1000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector41
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Digital-to-Analog Converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector41(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA25_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the digital-to-analog converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector41(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA25_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Keyboard interrupt interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector41(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA25_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the inter-integrated circuit 1 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector41(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector41(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector43
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Multipurpose Clock Generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector43(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the multipurpose clock generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector43(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA27_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Clock loss of lock interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector43(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the serial peripheral interface 1 interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector43(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector43(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x8000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector44
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Disables the Low-Power Timer interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector44(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA28_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the WDOG interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector44(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the integrated interchip sound 0 transmit interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector44(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector44(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x10000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector45
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Programmable Delay Block interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector45(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA29_MASK \
    )
#elif ((defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Pulse width timer interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector45(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the integrated interchip sound 0 receive interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector45(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector45(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x20000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableInterrupts
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Enables interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_DMA0_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_EnableInterrupts(PeripheralBase, Mask) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#else /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Enables interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_FTMRE_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_EnableInterrupts(PeripheralBase, Mask) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#endif /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- DisableInterrupts
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Disables interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to disable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_DMA0_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_DisableInterrupts(PeripheralBase, Mask) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#else /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Disables interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to disable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_FTMRE_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_DisableInterrupts(PeripheralBase, Mask) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#endif /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- SetInterruptMask
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Sets all interrupts with value according to mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable - rest will be disabled. Use
 *        constants from group "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, NVIC_ICER
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetInterruptMask(<peripheral>_BASE_PTR,
 *      NVIC_PDD_DMA0_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_SetInterruptMask(PeripheralBase, Mask) ( \
      (NVIC_ISER_REG(PeripheralBase) = \
       (uint32_t)(Mask)), \
      (NVIC_ICER_REG(PeripheralBase) = \
       (uint32_t)(~(uint32_t)(Mask))) \
    )
#else /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Sets all interrupts with value according to mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable - rest will be disabled. Use
 *        constants from group "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, NVIC_ICER
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetInterruptMask(<peripheral>_BASE_PTR,
 *      NVIC_PDD_FTMRE_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_SetInterruptMask(PeripheralBase, Mask) ( \
      (NVIC_ISER_REG(PeripheralBase) = \
       (uint32_t)(Mask)), \
      (NVIC_ICER_REG(PeripheralBase) = \
       (uint32_t)(~(uint32_t)(Mask))) \
    )
#endif /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- GetInterruptMask
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns enabled interrupts mask.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Use constants from group "Interrupts' mask" for processing return
 *         value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetInterruptMask(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetInterruptMask(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingInterrupts
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Forces interrupts defined by mask parameter into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_DMA0_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingInterrupts(PeripheralBase, Mask) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#else /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Forces interrupts defined by mask parameter into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to enable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_FTMRE_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingInterrupts(PeripheralBase, Mask) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#endif /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingInterrupts
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Removes the pending state from interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to disable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_DMA0_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingInterrupts(PeripheralBase, Mask) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#else /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Removes the pending state from interrupts defined by mask parameter.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Mask Mask of interrupts to disable. Use constants from group
 *        "Interrupts' mask". This parameter is 32 bits wide.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingInterrupts(<peripheral>_BASE_PTR,
 *      NVIC_PDD_FTMRE_INTERRUPT_MASK);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingInterrupts(PeripheralBase, Mask) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       (uint32_t)(Mask) \
    )
#endif /* (defined(MCU_MKE04Z1284)) || (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- GetPendingInterruptMask
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns pending interrupts mask.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Use constants from group "Interrupts' mask" for processing return
 *         value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetPendingInterruptMask(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingInterruptMask(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) \
  )

/* ----------------------------------------------------------------------------
   -- SetCanRxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Freescale's Scalable Controller
 * Area Network Rx interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCanRxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetCanRxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetCanTxErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Freescale's Scalable Controller
 * Area Network Tx and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCanTxErrPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetCanTxErrPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- GetCanRxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Freescale's Scalable Controller
 * Area Network Rx interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanRxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanRxPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetCanTxErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Freescale's Scalable Controller
 * Area Network Tx and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanTxErrPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanTxErrPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the GPIOA Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector46(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector46(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the PORTA pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector46(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector46(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Sets the interrupt priority of the Freescale's Scalable Controller
 * Area Network Rx interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector46(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector46(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the GPIOB, GPIOC, GPIOD and GPIOE Pin
 * detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector47(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector47(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the PORTC and PORTD pin detect
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector47(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector47(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Sets the interrupt priority of the Freescale's Scalable Controller
 * Area Network Tx and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector47(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector47(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the UART0 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector47(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector47(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,31U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the GPIOA Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector46(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the PORTA pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector46(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Returns the interrupt priority of the Freescale's Scalable Controller
 * Area Network Rx interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector46(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the GPIOB, GPIOC, GPIOD and GPIOE
 * Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector47(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the PORTC and PORTD pin detect
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector47(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns the interrupt priority of the Freescale's Scalable Controller
 * Area Network Tx and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector47(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the UART0 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector47(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,31U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetCanRxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Rx IRQ is pending for vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanRxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanRxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetCanTxErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Tx and error IRQ is pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanTxErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanTxErrPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- SetCanRxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCanRxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetCanRxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND30_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetCanTxErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCanTxErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetCanTxErrPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearCanRxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Freescale's Scalable Controller
 * Area Network Rx interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCanRxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearCanRxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND30_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearCanTxErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Freescale's Scalable Controller
 * Area Network Tx and error interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCanTxErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearCanTxErrPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetCanRxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Rx IRQ is enabled for vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanRxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanRxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetCanTxErrEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Tx and error IRQ is enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCanTxErrEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCanTxErrEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- EnableCanRx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCanRx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableCanRx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA30_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableCanTxErr
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCanTxErr(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableCanTxErr(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableCanRx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCanRx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableCanRx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA30_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableCanTxErr
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCanTxErr(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableCanTxErr(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOA Pin detect IRQ is pending for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the PORTA pin detect IRQ is pending for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Rx IRQ is pending for vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOB, GPIOC, GPIOD and GPIOE Pin detect
 * IRQ is pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the PORTC and PORTD pin detect IRQ is
 * pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Tx and error IRQ is pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the UART0 receive/transmit IRQ is pending
 * for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 31U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces GPIOA Pin detect interrupt vector number 46 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector46(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND30_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces PORTA pin detect interrupt vector number 46 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector46(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND30_MASK \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Forces Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector46(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND30_MASK \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector47(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND31_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces PORTC and PORTD pin detect interrupt vector number 47 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector47(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND31_MASK \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Forces Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector47(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND31_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces UART0 receive/transmit interrupt vector number 47 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector47(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x80000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the GPIOA Pin detect interrupt vector
 * number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector46(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND30_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the PORTA pin detect interrupt vector
 * number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector46(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND30_MASK \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Removes the pending state from the Freescale's Scalable Controller
 * Area Network Rx interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector46(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND30_MASK \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the GPIOB, GPIOC, GPIOD and GPIOE Pin
 * detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector47(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND31_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the PORTC and PORTD pin detect
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector47(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND31_MASK \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Removes the pending state from the Freescale's Scalable Controller
 * Area Network Tx and error interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector47(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND31_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the UART0 receive/transmit interrupt
 * vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector47(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x80000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOA Pin detect IRQ is enabled for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the PORTA pin detect IRQ is enabled for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Rx IRQ is enabled for vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector46(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOB, GPIOC, GPIOD and GPIOE Pin detect
 * IRQ is enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the PORTC and PORTD pin detect IRQ is
 * enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Returns non-zero value if the Freescale's Scalable Controller Area
 * Network Tx and error IRQ is enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the UART0 receive/transmit IRQ is enabled
 * for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector47(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the GPIOA Pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector46(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA30_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the PORTA pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector46(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA30_MASK \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Enables the Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector46(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA30_MASK \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- EnableVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector47(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA31_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the PORTC and PORTD pin detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector47(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA31_MASK \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Enables the Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector47(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA31_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the UART0 receive/transmit interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector47(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x80000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector46
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the GPIOA Pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector46(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA30_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the PORTA pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector46(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA30_MASK \
    )
#else /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */
/**
 * @brief Disables the Freescale's Scalable Controller Area Network Rx interrupt
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector46(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector46(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA30_MASK \
    )
#endif /* (defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)) */

/* ----------------------------------------------------------------------------
   -- DisableVector47
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector47(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA31_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the PORTC and PORTD pin detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector47(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA31_MASK \
    )
#elif ((defined(MCU_MKE06Z4)) || (defined(MCU_SKEAZ1284)))
/**
 * @brief Disables the Freescale's Scalable Controller Area Network Tx and error
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector47(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA31_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the UART0 receive/transmit interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector47(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector47(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x80000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma2Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma3Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDmaErrorPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 1 2 3 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDmaErrorPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDmaErrorPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 0 - 15 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDmaErrorPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDmaErrorPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,16U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtfaPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Command complete and read collision
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtfaPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtfaPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Sets the interrupt priority of the FTFA command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtfaPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetFtfaPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetLlwuPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Low Leakage Wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,21U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAdc0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,39U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAdc1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Analog-to-Digital Converter 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetAdc1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
      (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetCmp0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,40U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetCmp1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp1Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,41U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetWdogEwmPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogEwmPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetWdogEwmPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the single interrupt vector for  WDOG
 * and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogEwmPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetWdogEwmPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,22U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDac0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Digital-to-Analog Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDac0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDac0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Sets the interrupt priority of the digital-to-analog converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDac0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetDac0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetMcgPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Multipurpose Clock Generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,57U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetLptmr0Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Sets the interrupt priority of the Low-Power Timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLptmr0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetLptmr0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the low power timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLptmr0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetLptmr0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,58U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPdb0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the Programmable Delay Block interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPdb0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPdb0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the programmable delay block interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPdb0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPdb0Priority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,52U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPortaPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the GPIOA Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPortaPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Sets the interrupt priority of the PORTA pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPortaPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,7U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetPortaPortbPotcPortdPortePriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the GPIOB, GPIOC, GPIOD and GPIOE Pin
 * detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPortbPotcPortdPortePriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortaPortbPotcPortdPortePriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,0U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma2Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,2U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma3Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma3Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,3U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDmaErrorPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 1 2 3 error
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDmaErrorPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorPriority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 0 - 15 error
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDmaErrorPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,16U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtfaPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns the interrupt priority of the FTFA command complete and read
 * collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetLlwuPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Low Leakage Wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the low leakage wakeup interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetLlwuPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,21U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Analog-to-Digital Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,3U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetAdc0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,39U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Analog-to-Digital Converter 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdc1Priority(PeripheralBase) ( \
    (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmp0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the Comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetCmp0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,40U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetCmp1Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetCmp1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,41U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetWdogEwmPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEwmPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the single interrupt vector for
 * WDOG and EWM interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetWdogEwmPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,22U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDac0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Digital-to-Analog Converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns the interrupt priority of the digital-to-analog converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetMcgPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Multipurpose Clock Generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetMcgPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,57U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetLptmr0Priority
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns the interrupt priority of the Low-Power Timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLptmr0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Priority(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the low power timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetLptmr0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,58U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPdb0Priority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the Programmable Delay Block
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPdb0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Priority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the programmable delay block
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPdb0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Priority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,52U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPortaPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the GPIOA Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns the interrupt priority of the PORTA pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetPortaPortbPotcPortdPortePriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the GPIOB, GPIOC, GPIOD and GPIOE
 * Pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetPortaPortbPotcPortdPortePriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortaPortbPotcPortdPortePriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector16(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector16(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector16(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector16(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector16(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector16(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector17(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector17(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector17(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector17(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector17(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector17(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector18(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector18(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector18(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector18(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector18(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector18(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,2U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector19(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector19(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete and
 * error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector19(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector19(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,0U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector19(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector19(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,3U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPriorityVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Sets the interrupt priority of the DMA channel 0 1 2 3 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector20(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector20(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,1U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK))) | ( \
        (uint32_t)((uint32_t)(Priority) & NVIC_IP_PRI_0_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the DMA channel 4 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector20(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector20(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,4U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 0 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector16(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,0U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector17(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector17(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 1 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector17(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector18(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector18(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 2 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector18(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,2U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector19(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * and error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector19(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,0U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
       24U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 3 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector19(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,3U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns the interrupt priority of the DMA channel 0 1 2 3 error
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector20(PeripheralBase) ( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_0_MASK)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the DMA channel 4 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector20(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,4U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND0_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete and
 * error IRQ is pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND0_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)0x1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND1_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete and
 * error IRQ is pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND1_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 1U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma2Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND2_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete and
 * error IRQ is pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND2_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 2U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma3Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND3_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete and
 * error IRQ is pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND3_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 3U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDmaErrorPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 1 2 3 error IRQ is pending
 * for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND4_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 - 15 error IRQ is pending
 * for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 16U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtfaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND5_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the FTFA command complete and read collision
 * IRQ is pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND5_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetLlwuPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Low Leakage Wakeup IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is pending for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND7_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is pending for
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 21U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND15_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Analog-to-digital converter 0 IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND15_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the analog-to-digital converter 0 IRQ is
 * pending for vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 7U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 1 IRQ is
 * pending for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdc1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmp0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is pending for vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND20_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is pending for vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND16_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the comparator 0 IRQ is pending for vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 8U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetCmp1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 1 IRQ is pending for vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the comparator 1 IRQ is pending for vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 9U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetWdogEwmPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the WDOG and EWM IRQ is pending for vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND23_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the single interrupt vector for  WDOG and
 * EWM IRQ is pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 22U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDac0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Digital-to-Analog Converter 0 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the digital-to-analog converter 0 IRQ is
 * pending for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND25_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetMcgPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Multipurpose Clock Generator IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * pending for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND27_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * pending for vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 25U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetLptmr0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns non-zero value if the Low-Power Timer IRQ is pending for
 * vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND28_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low power timer IRQ is pending for
 * vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 26U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPdb0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Programmable Delay Block IRQ is pending
 * for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND29_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the programmable delay block IRQ is pending
 * for vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Pending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 20U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPortaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOA Pin detect IRQ is pending for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the PORTA pin detect IRQ is pending for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND30_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetPortaPortbPotcPortdPortePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the GPIOB, GPIOC, GPIOD and GPIOE Pin detect
 * IRQ is pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetPortaPortbPotcPortdPortePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortaPortbPotcPortdPortePending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 0 transfer complete interrupt vector number 16 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 0 transfer complete and error interrupt vector
 * number 16 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 0 transfer complete interrupt vector number 16 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 1 transfer complete interrupt vector number 17 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 1 transfer complete and error interrupt vector
 * number 17 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 1 transfer complete interrupt vector number 17 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma2Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 2 transfer complete interrupt vector number 18 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 2 transfer complete and error interrupt vector
 * number 18 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 2 transfer complete interrupt vector number 18 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma2Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma3Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 3 transfer complete interrupt vector number 19 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 3 transfer complete and error interrupt vector
 * number 19 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 3 transfer complete interrupt vector number 19 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDma3Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDmaErrorPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 0 1 2 3 error interrupt vector number 20 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDmaErrorPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 0 - 15 error interrupt vector number 32 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDmaErrorPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetFtfaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Command complete and read collision interrupt vector number 21
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtfaPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND5_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Forces FTFA command complete and read collision interrupt vector
 * number 21 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetFtfaPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND5_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetLlwuPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Low Leakage Wakeup interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces low leakage wakeup interrupt vector number 23 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces low leakage wakeup interrupt vector number 37 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetLlwuPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAdc0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Analog-to-Digital Converter 0 interrupt vector number 31 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND15_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces Analog-to-digital converter 0 interrupt vector number 31 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces analog-to-digital converter 0 interrupt vector number 55 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetAdc0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetAdc1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Analog-to-Digital Converter 1 interrupt vector number 32 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetAdc1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetAdc1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetCmp0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Comparator 0 interrupt vector number 36 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces Comparator 0 interrupt vector number 32 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces comparator 0 interrupt vector number 56 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetCmp1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Comparator 1 interrupt vector number 37 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces comparator 1 interrupt vector number 57 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetCmp1Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetWdogEwmPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces WDOG and EWM interrupt vector number 39 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetWdogEwmPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces single interrupt vector for  WDOG and EWM interrupt vector
 * number 38 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetWdogEwmPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDac0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Digital-to-Analog Converter 0 interrupt vector number 41 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDac0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND25_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Forces digital-to-analog converter 0 interrupt vector number 41 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetDac0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND25_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetMcgPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Multipurpose Clock Generator interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces multipurpose clock generator interrupt vector number 43 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces multipurpose clock generator interrupt vector number 73 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetMcgPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetLptmr0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Forces Low-Power Timer interrupt vector number 44 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetLptmr0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces low power timer interrupt vector number 74 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetLptmr0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPdb0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces Programmable Delay Block interrupt vector number 45 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPdb0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces programmable delay block interrupt vector number 68 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPdb0Pending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPortaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces GPIOA Pin detect interrupt vector number 46 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPortaPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND30_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Forces PORTA pin detect interrupt vector number 46 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPortaPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND30_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- SetPortaPortbPotcPortdPortePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortaPortbPotcPortdPortePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortaPortbPotcPortdPortePending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete
 * interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete and
 * error interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete
 * interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearDma1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete
 * interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete and
 * error interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete
 * interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearDma2Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete
 * interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma2Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete and
 * error interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma2Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete
 * interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma2Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearDma3Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete
 * interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma3Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete and
 * error interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma3Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete
 * interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDma3Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearDmaErrorPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 0 1 2 3 error interrupt
 * vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDmaErrorPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 0 - 15 error interrupt
 * vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDmaErrorPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDmaErrorPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearFtfaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Command complete and read collision
 * interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtfaPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND5_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Removes the pending state from the FTFA command complete and read
 * collision interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtfaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearFtfaPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND5_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- ClearLlwuPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Low Leakage Wakeup interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearLlwuPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the low leakage wakeup interrupt vector
 * number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearLlwuPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the low leakage wakeup interrupt vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLlwuPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearLlwuPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearAdc0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Analog-to-Digital Converter 0
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearAdc0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND15_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Analog-to-digital converter 0
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearAdc0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the analog-to-digital converter 0
 * interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAdc0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearAdc0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearAdc1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Analog-to-Digital Converter 1
 * interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearAdc1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearAdc1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearCmp0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Comparator 0 interrupt vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearCmp0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the Comparator 0 interrupt vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearCmp0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the comparator 0 interrupt vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmp0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearCmp0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearCmp1Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Comparator 1 interrupt vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearCmp1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the comparator 1 interrupt vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmp1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearCmp1Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearWdogEwmPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the WDOG and EWM interrupt vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearWdogEwmPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the single interrupt vector for  WDOG
 * and EWM interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearWdogEwmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearWdogEwmPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearDac0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Digital-to-Analog Converter 0
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDac0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND25_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Removes the pending state from the digital-to-analog converter 0
 * interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDac0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearDac0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND25_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- ClearMcgPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Multipurpose Clock Generator
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearMcgPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the multipurpose clock generator
 * interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearMcgPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the multipurpose clock generator
 * interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearMcgPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearMcgPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearLptmr0Pending
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Removes the pending state from the Low-Power Timer interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearLptmr0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the low power timer interrupt vector
 * number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLptmr0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearLptmr0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPdb0Pending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the Programmable Delay Block interrupt
 * vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPdb0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the programmable delay block interrupt
 * vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPdb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPdb0Pending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPortaPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the GPIOA Pin detect interrupt vector
 * number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPortaPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND30_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Removes the pending state from the PORTA pin detect interrupt vector
 * number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortaPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPortaPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND30_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- ClearPortaPortbPotcPortdPortePending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the GPIOB, GPIOC, GPIOD and GPIOE Pin
 * detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortaPortbPotcPortdPortePending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortaPortbPotcPortdPortePending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetDma0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA0_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete and
 * error IRQ is enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA0_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma1Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA1_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete and
 * error IRQ is enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA1_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma2Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA2_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete and
 * error IRQ is enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA2_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma2Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDma3Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA3_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete and
 * error IRQ is enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA3_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma3Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDma3Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDmaErrorEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 1 2 3 error IRQ is enabled
 * for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDmaErrorEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA4_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 - 15 error IRQ is enabled
 * for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDmaErrorEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDmaErrorEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetFtfaEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Command complete and read collision IRQ
 * is enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA5_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the FTFA command complete and read collision
 * IRQ is enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtfaEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetFtfaEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA5_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetLlwuEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Low Leakage Wakeup IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is enabled for
 * vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA7_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low leakage wakeup IRQ is enabled for
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLlwuEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLlwuEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x200000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 0 IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA15_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Analog-to-digital converter 0 IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA15_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the analog-to-digital converter 0 IRQ is
 * enabled for vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetAdc0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetAdc1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Analog-to-Digital Converter 1 IRQ is
 * enabled for vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetAdc1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetAdc1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmp0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is enabled for vector
 * number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA20_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the Comparator 0 IRQ is enabled for vector
 * number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA16_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the comparator 0 IRQ is enabled for vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x100U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetCmp1Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Comparator 1 IRQ is enabled for vector
 * number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the comparator 1 IRQ is enabled for vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmp1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetCmp1Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x200U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetWdogEwmEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the WDOG and EWM IRQ is enabled for vector
 * number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEwmEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA23_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the single interrupt vector for  WDOG and
 * EWM IRQ is enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetWdogEwmEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetWdogEwmEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x400000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetDac0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Digital-to-Analog Converter 0 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the digital-to-analog converter 0 IRQ is
 * enabled for vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDac0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetDac0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA25_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetMcgEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Multipurpose Clock Generator IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * enabled for vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA27_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * enabled for vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcgEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetMcgEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetLptmr0Enabled
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Returns non-zero value if the Low-Power Timer IRQ is enabled for
 * vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLptmr0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA28_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the low power timer IRQ is enabled for
 * vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLptmr0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetLptmr0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPdb0Enabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the Programmable Delay Block IRQ is enabled
 * for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPdb0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA29_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the programmable delay block IRQ is enabled
 * for vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPdb0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPdb0Enabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x100000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPortaEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the GPIOA Pin detect IRQ is enabled for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Returns non-zero value if the PORTA pin detect IRQ is enabled for
 * vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortaEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPortaEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA30_MASK) \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- GetPortaPortbPotcPortdPorteEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the GPIOB, GPIOC, GPIOD and GPIOE Pin detect
 * IRQ is enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetPortaPortbPotcPortdPorteEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortaPortbPotcPortdPorteEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 0 transfer complete interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 0 transfer complete and error interrupt vector
 * number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 0 transfer complete interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableDma1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 1 transfer complete interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 1 transfer complete and error interrupt vector
 * number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 1 transfer complete interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableDma2
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 2 transfer complete interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma2(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 2 transfer complete and error interrupt vector
 * number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma2(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 2 transfer complete interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma2(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableDma3
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 3 transfer complete interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma3(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 3 transfer complete and error interrupt vector
 * number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma3(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 3 transfer complete interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDma3(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableDmaError
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 0 1 2 3 error interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDmaError(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDmaError(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 0 - 15 error interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDmaError(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDmaError(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableFtfa
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtfa(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtfa(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA5_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Enables the FTFA command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtfa(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableFtfa(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA5_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- EnableLlwu
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Low Leakage Wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableLlwu(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the low leakage wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableLlwu(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the low leakage wakeup interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableLlwu(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableAdc0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableAdc0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA15_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Analog-to-digital converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableAdc0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the analog-to-digital converter 0 interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableAdc0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableAdc1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Analog-to-Digital Converter 1 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableAdc1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableAdc1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableCmp0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Comparator 0 interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableCmp0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the Comparator 0 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableCmp0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the comparator 0 interrupt vector number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableCmp0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableCmp1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Comparator 1 interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableCmp1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the comparator 1 interrupt vector number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableCmp1(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableWdogEwm
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the WDOG and EWM interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableWdogEwm(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableWdogEwm(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the single interrupt vector for  WDOG and EWM interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableWdogEwm(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableWdogEwm(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableDac0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Digital-to-Analog Converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDac0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDac0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA25_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Enables the digital-to-analog converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDac0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableDac0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA25_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- EnableMcg
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Multipurpose Clock Generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableMcg(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the multipurpose clock generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableMcg(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the multipurpose clock generator interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableMcg(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableLptmr0
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Enables the Low-Power Timer interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLptmr0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableLptmr0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the low power timer interrupt vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLptmr0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableLptmr0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnablePdb0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the Programmable Delay Block interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePdb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePdb0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the programmable delay block interrupt vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePdb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePdb0(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnablePorta
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the GPIOA Pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePorta(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePorta(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA30_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Enables the PORTA pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePorta(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnablePorta(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA30_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- EnablePortaPortbPotcPortdPorte
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortaPortbPotcPortdPorte(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortaPortbPotcPortdPorte(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 0 transfer complete interrupt vector number
 * 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 0 transfer complete and error interrupt
 * vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 0 transfer complete interrupt vector number
 * 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableDma1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 1 transfer complete interrupt vector number
 * 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 1 transfer complete and error interrupt
 * vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 1 transfer complete interrupt vector number
 * 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableDma2
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 2 transfer complete interrupt vector number
 * 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma2(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 2 transfer complete and error interrupt
 * vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma2(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 2 transfer complete interrupt vector number
 * 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma2(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma2(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableDma3
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 3 transfer complete interrupt vector number
 * 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma3(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 3 transfer complete and error interrupt
 * vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma3(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 3 transfer complete interrupt vector number
 * 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma3(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDma3(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableDmaError
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 0 1 2 3 error interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDmaError(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDmaError(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 0 - 15 error interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDmaError(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDmaError(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x10000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableFtfa
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtfa(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtfa(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA5_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Disables the FTFA command complete and read collision interrupt vector
 * number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtfa(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableFtfa(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA5_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- DisableLlwu
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Low Leakage Wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableLlwu(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA7_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the low leakage wakeup interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableLlwu(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA7_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the low leakage wakeup interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLlwu(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableLlwu(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x200000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableAdc0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Analog-to-Digital Converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableAdc0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA15_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Analog-to-digital converter 0 interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableAdc0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA15_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the analog-to-digital converter 0 interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAdc0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableAdc0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x80U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableAdc1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Analog-to-Digital Converter 1 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableAdc1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableAdc1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA16_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableCmp0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Comparator 0 interrupt vector number 36.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableCmp0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA20_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the Comparator 0 interrupt vector number 32.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableCmp0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA16_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the comparator 0 interrupt vector number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmp0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableCmp0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x100U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableCmp1
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Comparator 1 interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableCmp1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the comparator 1 interrupt vector number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmp1(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableCmp1(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x200U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableWdogEwm
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the WDOG and EWM interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableWdogEwm(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableWdogEwm(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA23_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the single interrupt vector for  WDOG and EWM interrupt
 * vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableWdogEwm(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableWdogEwm(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x400000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableDac0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Digital-to-Analog Converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDac0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDac0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA25_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Disables the digital-to-analog converter 0 interrupt vector number 41.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDac0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableDac0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA25_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- DisableMcg
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Multipurpose Clock Generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableMcg(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA27_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the multipurpose clock generator interrupt vector number 43.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableMcg(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA27_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the multipurpose clock generator interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableMcg(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableMcg(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x2000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableLptmr0
   ---------------------------------------------------------------------------- */

#if ((defined(MCU_MKV10Z7)) || (defined(MCU_MKW01Z4)))
/**
 * @brief Disables the Low-Power Timer interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLptmr0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableLptmr0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA28_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the low power timer interrupt vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLptmr0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableLptmr0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisablePdb0
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the Programmable Delay Block interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePdb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePdb0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA29_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the programmable delay block interrupt vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePdb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePdb0(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x100000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisablePorta
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the GPIOA Pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePorta(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePorta(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA30_MASK \
    )
#else /* defined(MCU_MKW01Z4) */
/**
 * @brief Disables the PORTA pin detect interrupt vector number 46.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePorta(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisablePorta(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA30_MASK \
    )
#endif /* defined(MCU_MKW01Z4) */

/* ----------------------------------------------------------------------------
   -- DisablePortaPortbPotcPortdPorte
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the GPIOB, GPIOC, GPIOD and GPIOE Pin detect interrupt vector
 * number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortaPortbPotcPortdPorte(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortaPortbPotcPortdPorte(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND0_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete and
 * error IRQ is pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND0_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * pending for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)0x1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND1_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete and
 * error IRQ is pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND1_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * pending for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 1U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND2_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete and
 * error IRQ is pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND2_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * pending for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 2U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND3_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete and
 * error IRQ is pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND3_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * pending for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 3U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPendingVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 1 2 3 error IRQ is pending
 * for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector20(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND4_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 4 transfer complete IRQ is
 * pending for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector20(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 4U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 0 transfer complete interrupt vector number 16 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector16(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 0 transfer complete and error interrupt vector
 * number 16 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector16(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 0 transfer complete interrupt vector number 16 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector16(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 1 transfer complete interrupt vector number 17 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector17(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 1 transfer complete and error interrupt vector
 * number 17 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector17(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 1 transfer complete interrupt vector number 17 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector17(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 2 transfer complete interrupt vector number 18 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector18(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 2 transfer complete and error interrupt vector
 * number 18 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector18(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 2 transfer complete interrupt vector number 18 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector18(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 3 transfer complete interrupt vector number 19 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector19(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Forces DMA channel 3 transfer complete and error interrupt vector
 * number 19 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector19(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 3 transfer complete interrupt vector number 19 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector19(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Forces DMA channel 0 1 2 3 error interrupt vector number 20 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector20(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces DMA channel 4 transfer complete interrupt vector number 20 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector20(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x10U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete
 * interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector16(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete and
 * error interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector16(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 0 transfer complete
 * interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector16(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete
 * interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector17(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete and
 * error interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector17(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 1 transfer complete
 * interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector17(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete
 * interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector18(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete and
 * error interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector18(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 2 transfer complete
 * interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector18(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete
 * interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector19(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete and
 * error interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector19(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 3 transfer complete
 * interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector19(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Removes the pending state from the DMA channel 0 1 2 3 error interrupt
 * vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector20(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the DMA channel 4 transfer complete
 * interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector20(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x10U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA0_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete and
 * error IRQ is enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA0_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 0 transfer complete IRQ is
 * enabled for vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector16(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA1_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete and
 * error IRQ is enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA1_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 1 transfer complete IRQ is
 * enabled for vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector17(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA2_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete and
 * error IRQ is enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA2_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 2 transfer complete IRQ is
 * enabled for vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector18(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA3_MASK) \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete and
 * error IRQ is enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA3_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 3 transfer complete IRQ is
 * enabled for vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector19(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Returns non-zero value if the DMA channel 0 1 2 3 error IRQ is enabled
 * for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector20(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA4_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the DMA channel 4 transfer complete IRQ is
 * enabled for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector20(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 0 transfer complete interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector16(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 0 transfer complete and error interrupt vector
 * number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector16(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 0 transfer complete interrupt vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector16(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 1 transfer complete interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector17(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 1 transfer complete and error interrupt vector
 * number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector17(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 1 transfer complete interrupt vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector17(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 2 transfer complete interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector18(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 2 transfer complete and error interrupt vector
 * number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector18(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 2 transfer complete interrupt vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector18(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 3 transfer complete interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector19(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Enables the DMA channel 3 transfer complete and error interrupt vector
 * number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector19(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 3 transfer complete interrupt vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector19(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Enables the DMA channel 0 1 2 3 error interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector20(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the DMA channel 4 transfer complete interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector20(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x10U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector16
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 0 transfer complete interrupt vector number
 * 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector16(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA0_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 0 transfer complete and error interrupt
 * vector number 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector16(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA0_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 0 transfer complete interrupt vector number
 * 16.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector16(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector16(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x1U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector17
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 1 transfer complete interrupt vector number
 * 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector17(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA1_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 1 transfer complete and error interrupt
 * vector number 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector17(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA1_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 1 transfer complete interrupt vector number
 * 17.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector17(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector17(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x2U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector18
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 2 transfer complete interrupt vector number
 * 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector18(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA2_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 2 transfer complete and error interrupt
 * vector number 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector18(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA2_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 2 transfer complete interrupt vector number
 * 18.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector18(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector18(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x4U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector19
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 3 transfer complete interrupt vector number
 * 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector19(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA3_MASK \
    )
#elif (defined(MCU_MKW01Z4))
/**
 * @brief Disables the DMA channel 3 transfer complete and error interrupt
 * vector number 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector19(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA3_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 3 transfer complete interrupt vector number
 * 19.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector19(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector19(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x8U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector20
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKV10Z7))
/**
 * @brief Disables the DMA channel 0 1 2 3 error interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector20(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA4_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the DMA channel 4 transfer complete interrupt vector number
 * 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector20(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector20(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x10U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetLvdLvwPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the low-voltage detect and low-voltage
 * warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLvdLvwPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetLvdLvwPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,1U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Timer PWM module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetTpm0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Timer PWM module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetTpm1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the Timer PWM module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetTpm2Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetRtcSecondsPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the real time clock seconds interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcSecondsPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcSecondsPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,5U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 8U) & NVIC_IP_PRI_1_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the real time clock seconds interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcSecondsPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcSecondsPriority(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,47U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPitPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer all
 * channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPitPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,5U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetTsi0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the touch sensing input interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTsi0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetTsi0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,6U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortbPotcPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the PORTC and PORTD pin detect
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortbPotcPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortbPotcPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint32_t)(( \
      (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) | ( \
      (uint32_t)((uint32_t)((uint32_t)(Priority) << 24U) & NVIC_IP_PRI_3_MASK))) \
  )

/* ----------------------------------------------------------------------------
   -- GetLvdLvwPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the low-voltage detect and
 * low-voltage warning interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLvdLvwPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetLvdLvwPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,1U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Timer PWM module 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm0Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
     8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Timer PWM module 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm1Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the Timer PWM module 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm2Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,4U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetRtcSecondsPriority
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the real time clock seconds
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcSecondsPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsPriority(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_1_MASK))) >> ( \
       8U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the real time clock seconds
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetRtcSecondsPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsPriority(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,47U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPitPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer all
 * channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,5U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetTsi0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the touch sensing input interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTsi0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTsi0Priority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
     16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortbPotcPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the PORTC and PORTD pin detect
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortbPotcPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortbPotcPriority(PeripheralBase) ( \
    (uint32_t)(( \
     (uint32_t)(NVIC_IP_REG(PeripheralBase,7U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_3_MASK))) >> ( \
     24U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Sets the interrupt priority of the touch sensing input interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 192(lowest), 128, 64 and 0(highest) are valid. This parameter is a
 *        32-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector42(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector42(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,6U) = \
       (uint32_t)(( \
        (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) | ( \
        (uint32_t)((uint32_t)((uint32_t)(Priority) << 16U) & NVIC_IP_PRI_2_MASK))) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Sets the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector42(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
  #define NVIC_PDD_SetPriorityVector42(PeripheralBase, Priority) ( \
      NVIC_IP_REG(PeripheralBase,26U) = \
       (uint8_t)(Priority) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPriorityVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns the interrupt priority of the touch sensing input interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPriorityVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector42(PeripheralBase) ( \
      (uint32_t)(( \
       (uint32_t)(NVIC_IP_REG(PeripheralBase,6U) & (uint32_t)(~(uint32_t)NVIC_IP_PRI_2_MASK))) >> ( \
       16U)) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns the interrupt priority of the serial peripheral interface 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPriorityVector42(PeripheralBase) ( \
      NVIC_IP_REG(PeripheralBase,26U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetLvdLvwPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the low-voltage detect and low-voltage
 * warning IRQ is pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLvdLvwPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetLvdLvwPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND6_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 0 IRQ is pending for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND17_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 1 IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND18_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 2 IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm2Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND19_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetRtcSecondsPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is pending
 * for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is pending
 * for vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsPending(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 15U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPitPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer all channels
 * IRQ is pending for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND22_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTsi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the touch sensing input IRQ is pending for
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTsi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTsi0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND26_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortbPotcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the PORTC and PORTD pin detect IRQ is
 * pending for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortbPotcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortbPotcPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- SetLvdLvwPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces low-voltage detect and low-voltage warning interrupt vector
 * number 22 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetLvdLvwPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetLvdLvwPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND6_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Timer PWM module 0 interrupt vector number 33 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetTpm0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND17_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Timer PWM module 1 interrupt vector number 34 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetTpm1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND18_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetTpm2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces Timer PWM module 2 interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTpm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetTpm2Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND19_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetRtcSecondsPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces real time clock seconds interrupt vector number 37 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcSecondsPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces real time clock seconds interrupt vector number 63 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetRtcSecondsPending(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,1U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPitPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer all channels interrupt vector number
 * 38 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPitPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPitPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetTsi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces touch sensing input interrupt vector number 42 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetTsi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetTsi0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND26_MASK \
  )

/* ----------------------------------------------------------------------------
   -- SetPortbPotcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces PORTC and PORTD pin detect interrupt vector number 47 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortbPotcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortbPotcPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase) = \
     NVIC_ISPR_SETPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearLvdLvwPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the low-voltage detect and low-voltage
 * warning interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearLvdLvwPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearLvdLvwPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND6_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearTpm0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Timer PWM module 0 interrupt vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearTpm0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearTpm0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND17_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearTpm1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Timer PWM module 1 interrupt vector
 * number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearTpm1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearTpm1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND18_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearTpm2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the Timer PWM module 2 interrupt vector
 * number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearTpm2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearTpm2Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND19_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearRtcSecondsPending
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the real time clock seconds interrupt
 * vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearRtcSecondsPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the real time clock seconds interrupt
 * vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRtcSecondsPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearRtcSecondsPending(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,1U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPitPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer all
 * channels interrupt vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPitPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPitPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearTsi0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the touch sensing input interrupt
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearTsi0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearTsi0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND26_MASK \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortbPotcPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the PORTC and PORTD pin detect
 * interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR.
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortbPotcPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortbPotcPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase) = \
     NVIC_ICPR_CLRPEND31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetLvdLvwEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the low-voltage detect and low-voltage
 * warning IRQ is enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetLvdLvwEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetLvdLvwEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA6_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 0 IRQ is enabled for
 * vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA17_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 1 IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA18_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTpm2Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the Timer PWM module 2 IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTpm2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTpm2Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA19_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetRtcSecondsEnabled
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is enabled
 * for vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcSecondsEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA21_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is enabled
 * for vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRtcSecondsEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetRtcSecondsEnabled(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetPitEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer all channels
 * IRQ is enabled for vector number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPitEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPitEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA22_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetTsi0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the touch sensing input IRQ is enabled for
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetTsi0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetTsi0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA26_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortbPotcEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the PORTC and PORTD pin detect IRQ is
 * enabled for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortbPotcEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortbPotcEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA31_MASK) \
  )

/* ----------------------------------------------------------------------------
   -- EnableLvdLvw
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the low-voltage detect and low-voltage warning interrupt
 * vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableLvdLvw(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableLvdLvw(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA6_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableTpm0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Timer PWM module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableTpm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableTpm0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA17_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableTpm1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Timer PWM module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableTpm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableTpm1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA18_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableTpm2
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the Timer PWM module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableTpm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableTpm2(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA19_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableRtcSeconds
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the real time clock seconds interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRtcSeconds(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableRtcSeconds(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the real time clock seconds interrupt vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRtcSeconds(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableRtcSeconds(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,1U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnablePit
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer all channels interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePit(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePit(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnableTsi0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the touch sensing input interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableTsi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableTsi0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA26_MASK \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortbPotc
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the PORTC and PORTD pin detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER.
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortbPotc(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortbPotc(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase) = \
     NVIC_ISER_SETENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableLvdLvw
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the low-voltage detect and low-voltage warning interrupt
 * vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableLvdLvw(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableLvdLvw(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA6_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableTpm0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Timer PWM module 0 interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableTpm0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableTpm0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA17_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableTpm1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Timer PWM module 1 interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableTpm1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableTpm1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA18_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableTpm2
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the Timer PWM module 2 interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableTpm2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableTpm2(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA19_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableRtcSeconds
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the real time clock seconds interrupt vector number 37.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRtcSeconds(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableRtcSeconds(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA21_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the real time clock seconds interrupt vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRtcSeconds(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableRtcSeconds(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,1U) = \
       0x8000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisablePit
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer all channels interrupt vector
 * number 38.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePit(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePit(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA22_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisableTsi0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the touch sensing input interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableTsi0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableTsi0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA26_MASK \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortbPotc
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the PORTC and PORTD pin detect interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER.
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortbPotc(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortbPotc(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase) = \
     NVIC_ICER_CLRENA31_MASK \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the touch sensing input IRQ is pending for
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector42(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase) & NVIC_ISPR_SETPEND26_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * pending for vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetPendingVector42(PeripheralBase) ( \
      (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 26U)) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetPendingVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Forces touch sensing input interrupt vector number 42 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector42(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase) = \
       NVIC_ISPR_SETPEND26_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Forces serial peripheral interface 0 interrupt vector number 42 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISPR, ISPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_SetPendingVector42(PeripheralBase) ( \
      NVIC_ISPR_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- ClearPendingVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Removes the pending state from the touch sensing input interrupt
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector42(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase) = \
       NVIC_ICPR_CLRPEND26_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Removes the pending state from the serial peripheral interface 0
 * interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICPR, ICPR[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_ClearPendingVector42(PeripheralBase) ( \
      NVIC_ICPR_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- GetEnabledVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Returns non-zero value if the touch sensing input IRQ is enabled for
 * vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector42(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase) & NVIC_ISER_SETENA26_MASK) \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Returns non-zero value if the serial peripheral interface 0 IRQ is
 * enabled for vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_GetEnabledVector42(PeripheralBase) ( \
      (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4000000U) \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- EnableVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Enables the touch sensing input interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector42(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase) = \
       NVIC_ISER_SETENA26_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Enables the serial peripheral interface 0 interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ISER, ISER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_EnableVector42(PeripheralBase) ( \
      NVIC_ISER_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- DisableVector42
   ---------------------------------------------------------------------------- */

#if (defined(MCU_MKW01Z4))
/**
 * @brief Disables the touch sensing input interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector42(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase) = \
       NVIC_ICER_CLRENA26_MASK \
    )
#else /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */
/**
 * @brief Disables the serial peripheral interface 0 interrupt vector number 42.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: NVIC_ICER, ICER[]
 *          (depending on the peripheral).
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector42(<peripheral>_BASE_PTR);
 *      @endcode
 */
  #define NVIC_PDD_DisableVector42(PeripheralBase) ( \
      NVIC_ICER_REG(PeripheralBase,0U) = \
       0x4000000U \
    )
#endif /* (defined(MCU_MKW21D5)) || (defined(MCU_MKW21D5WS)) || (defined(MCU_MKW22D5)) || (defined(MCU_MKW22D5WS)) || (defined(MCU_MKW24D5)) || (defined(MCU_MKW24D5WS)) */

/* ----------------------------------------------------------------------------
   -- SetDma4Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 4 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma4Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma4Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,4U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma5Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 5 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma5Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma5Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,5U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma6Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 6 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma6Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma6Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,6U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma7Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 7 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma7Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma7Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,7U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma8Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 8 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma8Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma8Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,8U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma9Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 9 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma9Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma9Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,9U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma10Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 10 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma10Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma10Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,10U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma11Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 11 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma11Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma11Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,11U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma12Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 12 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma12Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma12Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,12U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma13Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 13 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma13Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma13Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,13U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma14Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 14 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma14Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma14Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,14U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma15Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DMA channel 15 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma15Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDma15Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,15U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetMcmPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the MCM normal interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcmPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetMcmPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,17U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetFtflPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the FTFL command complete interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtflPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetFtflPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,18U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetFtflCollisionPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the FTFL read collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtflCollisionPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetFtflCollisionPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,19U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetRngPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the randon number generator interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRngPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetRngPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,23U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetI2S0TxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the integrated interchip sound 0
 * transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2S0TxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetI2S0TxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,28U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetI2S0RxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the integrated interchip sound 0
 * receive interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2S0RxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetI2S0RxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,29U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart0RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART0 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0RxTxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart0RxTxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,31U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart0ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART0 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0ErrPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart0ErrPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,32U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART1 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1RxTxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart1RxTxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,33U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART1 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1ErrPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart1ErrPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,34U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART2 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2RxTxPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart2RxTxPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,35U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART2 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2ErrPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUart2ErrPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,36U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetCmtPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the carrier modulator transmitter
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmtPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetCmtPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,45U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPit0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPit0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,48U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPit1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit1Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPit1Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,49U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPit2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 2
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit2Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPit2Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,50U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPit3Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 3
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit3Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPit3Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,51U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortAPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port a pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortAPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortAPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,59U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortBPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port b pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortBPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortBPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,60U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortCPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port c pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortCPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortCPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,61U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortDPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port d pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortDPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortDPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,62U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPortEPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port e pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortEPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPortEPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,63U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetSwiPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the software interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSwiPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetSwiPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,64U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma4Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 4 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma4Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma4Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,4U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma5Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 5 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma5Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma5Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,5U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma6Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 6 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma6Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma6Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,6U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma7Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 7 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma7Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma7Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,7U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma8Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 8 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma8Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma8Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,8U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma9Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 9 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma9Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma9Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,9U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma10Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 10 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma10Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma10Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,10U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma11Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 11 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma11Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma11Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,11U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma12Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 12 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma12Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma12Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,12U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma13Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 13 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma13Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma13Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,13U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma14Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 14 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma14Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma14Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,14U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma15Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DMA channel 15 transfer complete
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDma15Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma15Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,15U) \
  )

/* ----------------------------------------------------------------------------
   -- GetMcmPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the MCM normal interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetMcmPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetMcmPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,17U) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the FTFL command complete interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetFtflPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,18U) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflCollisionPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the FTFL read collision interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result =
 *      NVIC_PDD_GetFtflCollisionPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflCollisionPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,19U) \
  )

/* ----------------------------------------------------------------------------
   -- GetRngPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the randon number generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetRngPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetRngPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,23U) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0TxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the integrated interchip sound 0
 * transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetI2S0TxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0TxPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,28U) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0RxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the integrated interchip sound 0
 * receive interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetI2S0RxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0RxPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,29U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART0 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart0RxTxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0RxTxPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,31U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART0 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart0ErrPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0ErrPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,32U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART1 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart1RxTxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1RxTxPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,33U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART1 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart1ErrPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1ErrPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,34U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2RxTxPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART2 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart2RxTxPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2RxTxPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,35U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2ErrPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART2 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUart2ErrPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2ErrPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,36U) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmtPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the carrier modulator transmitter
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetCmtPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCmtPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,45U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPit0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit0Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,48U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit1Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPit1Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit1Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,49U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit2Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPit2Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit2Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,50U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit3Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 3 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPit3Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit3Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,51U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortAPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port a pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPortAPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortAPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,59U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortBPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port b pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPortBPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortBPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,60U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortCPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port c pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPortCPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortCPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,61U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortDPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port d pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPortDPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortDPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,62U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortEPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port e pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPortEPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortEPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,63U) \
  )

/* ----------------------------------------------------------------------------
   -- GetSwiPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the software interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetSwiPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetSwiPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,64U) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART0 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector48(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector48(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,32U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART1 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector49(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector49(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,33U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART1 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector50(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector50(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,34U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART2 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector51(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector51(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,35U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the UART2 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector52(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector52(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,36U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector55(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector55(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,39U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector56(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector56(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,40U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector57(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector57(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,41U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the FlexTimer module 0 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector58(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector58(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,42U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the FlexTimer module 1 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector59(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector59(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,43U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the FlexTimer module 2 fault, overflow
 * and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector60(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector60(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,44U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the carrier modulator transmitter
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector61(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector61(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,45U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the real time clock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector62(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector62(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,46U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the real time clock seconds interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector63(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector63(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,47U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector64(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector64(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,48U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 1
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector65(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector65(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,49U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 2
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector66(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector66(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,50U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the periodic interrupt timer channel 3
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector67(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector67(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,51U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the programmable delay block interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector68(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector68(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,52U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector73(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector73(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,57U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the low power timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector74(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector74(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,58U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port a pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector75(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector75(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,59U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port b pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector76(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector76(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,60U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port c pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector77(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector77(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,61U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port d pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector78(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector78(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,62U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the port e pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector79(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector79(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,63U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the software interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector80(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector80(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,64U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART0 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector48(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,32U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART1 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector49(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,33U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART1 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector50(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,34U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART2 receive/transmit interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector51(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,35U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the UART2 error interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector52(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,36U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the analog-to-digital converter 0
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector55(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,39U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the comparator 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector56(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,40U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the comparator 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector57(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,41U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the FlexTimer module 0 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector58(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,42U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the FlexTimer module 1 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector59(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,43U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the FlexTimer module 2 fault,
 * overflow and channels interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector60(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,44U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the carrier modulator transmitter
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector61(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,45U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the real time clock interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector62(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,46U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the real time clock seconds
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector63(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,47U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 0 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector64(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,48U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 1 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector65(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,49U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 2 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector66(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,50U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the periodic interrupt timer channel
 * 3 interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector67(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,51U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the programmable delay block
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector68(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,52U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the multipurpose clock generator
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector73(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,57U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the low power timer interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector74(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,58U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port a pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector75(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,59U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port b pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector76(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,60U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port c pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector77(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,61U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port d pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector78(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,62U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the port e pin detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector79(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,63U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the software interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector80(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,64U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma4Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 4 transfer complete IRQ is
 * pending for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma4Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma4Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 4U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma5Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 5 transfer complete IRQ is
 * pending for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma5Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma5Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 5U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma6Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 6 transfer complete IRQ is
 * pending for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma6Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma6Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 6U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma7Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 7 transfer complete IRQ is
 * pending for vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma7Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma7Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 7U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma8Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 8 transfer complete IRQ is
 * pending for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma8Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma8Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma9Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 9 transfer complete IRQ is
 * pending for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma9Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma9Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 9U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma10Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 10 transfer complete IRQ is
 * pending for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma10Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma10Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 10U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma11Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 11 transfer complete IRQ is
 * pending for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma11Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma11Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 11U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma12Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 12 transfer complete IRQ is
 * pending for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma12Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma12Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 12U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma13Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 13 transfer complete IRQ is
 * pending for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma13Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma13Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 13U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma14Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 14 transfer complete IRQ is
 * pending for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma14Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma14Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 14U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma15Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 15 transfer complete IRQ is
 * pending for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma15Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma15Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 15U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetMcmPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the MCM normal IRQ is pending for vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetMcmPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 17U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FTFL command complete IRQ is pending for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtflPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 18U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflCollisionPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FTFL read collision IRQ is pending for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetFtflCollisionPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflCollisionPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 19U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetRngPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the randon number generator IRQ is pending
 * for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRngPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetRngPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 23U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0TxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the integrated interchip sound 0 transmit
 * IRQ is pending for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2S0TxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0TxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 28U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0RxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the integrated interchip sound 0 receive IRQ
 * is pending for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2S0RxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0RxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 29U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 receive/transmit IRQ is pending
 * for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0RxTxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,0U) & (uint32_t)((uint32_t)0x1U << 31U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 error IRQ is pending for vector
 * number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0ErrPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 receive/transmit IRQ is pending
 * for vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1RxTxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 1U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 error IRQ is pending for vector
 * number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1ErrPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 2U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 receive/transmit IRQ is pending
 * for vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2RxTxPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 3U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 error IRQ is pending for vector
 * number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2ErrPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 4U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the carrier modulator transmitter IRQ is
 * pending for vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCmtPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 13U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 0 IRQ
 * is pending for vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 1 IRQ
 * is pending for vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit1Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 17U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 2 IRQ
 * is pending for vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit2Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 18U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit3Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 3 IRQ
 * is pending for vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit3Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 19U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortAPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port a pin detect IRQ is pending for
 * vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortAPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortAPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 27U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortBPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port b pin detect IRQ is pending for
 * vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortBPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortBPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 28U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortCPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port c pin detect IRQ is pending for
 * vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortCPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortCPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 29U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortDPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port d pin detect IRQ is pending for
 * vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortDPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortDPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 30U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortEPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port e pin detect IRQ is pending for
 * vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortEPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortEPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 31U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetSwiPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the software IRQ is pending for vector
 * number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSwiPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetSwiPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,2U) & (uint32_t)0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- SetDma4Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 4 transfer complete interrupt vector number 20 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma4Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma4Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma5Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 5 transfer complete interrupt vector number 21 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma5Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma5Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x20U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma6Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 6 transfer complete interrupt vector number 22 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma6Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma6Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x40U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma7Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 7 transfer complete interrupt vector number 23 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma7Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma7Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma8Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 8 transfer complete interrupt vector number 24 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma8Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma8Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma9Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 9 transfer complete interrupt vector number 25 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma9Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma9Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma10Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 10 transfer complete interrupt vector number 26
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma10Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma10Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma11Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 11 transfer complete interrupt vector number 27
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma11Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma11Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma12Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 12 transfer complete interrupt vector number 28
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma12Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma12Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma13Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 13 transfer complete interrupt vector number 29
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma13Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma13Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma14Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 14 transfer complete interrupt vector number 30
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma14Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma14Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- SetDma15Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DMA channel 15 transfer complete interrupt vector number 31
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDma15Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDma15Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- SetMcmPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces MCM normal interrupt vector number 33 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetMcmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetMcmPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- SetFtflPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces FTFL command complete interrupt vector number 34 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtflPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetFtflPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- SetFtflCollisionPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces FTFL read collision interrupt vector number 35 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetFtflCollisionPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetFtflCollisionPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- SetRngPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces randon number generator interrupt vector number 39 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetRngPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetRngPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- SetI2S0TxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces integrated interchip sound 0 transmit interrupt vector number
 * 44 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2S0TxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetI2S0TxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetI2S0RxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces integrated interchip sound 0 receive interrupt vector number 45
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetI2S0RxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetI2S0RxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart0RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART0 receive/transmit interrupt vector number 47 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart0RxTxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,0U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart0ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART0 error interrupt vector number 48 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart0ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart0ErrPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART1 receive/transmit interrupt vector number 49 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart1RxTxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart1ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART1 error interrupt vector number 50 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart1ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart1ErrPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART2 receive/transmit interrupt vector number 51 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart2RxTxPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- SetUart2ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART2 error interrupt vector number 52 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUart2ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUart2ErrPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- SetCmtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces carrier modulator transmitter interrupt vector number 61 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetCmtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetCmtPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPit0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 0 interrupt vector number 64
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPit0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPit1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 1 interrupt vector number 65
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPit1Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPit2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 2 interrupt vector number 66
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPit2Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPit3Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 3 interrupt vector number 67
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPit3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPit3Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPortAPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port a pin detect interrupt vector number 75 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortAPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortAPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPortBPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port b pin detect interrupt vector number 76 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortBPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortBPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPortCPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port c pin detect interrupt vector number 77 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortCPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortCPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPortDPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port d pin detect interrupt vector number 78 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortDPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortDPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPortEPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port e pin detect interrupt vector number 79 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPortEPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPortEPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetSwiPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces software interrupt vector number 80 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetSwiPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetSwiPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma4Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 4 transfer complete
 * interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma4Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma4Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma5Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 5 transfer complete
 * interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma5Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma5Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x20U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma6Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 6 transfer complete
 * interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma6Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma6Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x40U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma7Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 7 transfer complete
 * interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma7Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma7Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma8Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 8 transfer complete
 * interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma8Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma8Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma9Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 9 transfer complete
 * interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma9Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma9Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma10Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 10 transfer complete
 * interrupt vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma10Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma10Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma11Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 11 transfer complete
 * interrupt vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma11Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma11Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma12Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 12 transfer complete
 * interrupt vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma12Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma12Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma13Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 13 transfer complete
 * interrupt vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma13Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma13Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma14Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 14 transfer complete
 * interrupt vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma14Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma14Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDma15Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DMA channel 15 transfer complete
 * interrupt vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDma15Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDma15Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearMcmPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the MCM normal interrupt vector number
 * 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearMcmPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearMcmPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearFtflPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the FTFL command complete interrupt
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtflPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearFtflPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearFtflCollisionPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the FTFL read collision interrupt
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearFtflCollisionPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearFtflCollisionPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearRngPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the randon number generator interrupt
 * vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearRngPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearRngPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearI2S0TxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the integrated interchip sound 0
 * transmit interrupt vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2S0TxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearI2S0TxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearI2S0RxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the integrated interchip sound 0
 * receive interrupt vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearI2S0RxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearI2S0RxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart0RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART0 receive/transmit interrupt
 * vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart0RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart0RxTxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,0U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart0ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART0 error interrupt vector number
 * 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart0ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart0ErrPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart1RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART1 receive/transmit interrupt
 * vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart1RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart1RxTxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart1ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART1 error interrupt vector number
 * 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart1ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart1ErrPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart2RxTxPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART2 receive/transmit interrupt
 * vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart2RxTxPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart2RxTxPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUart2ErrPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART2 error interrupt vector number
 * 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUart2ErrPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUart2ErrPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- ClearCmtPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the carrier modulator transmitter
 * interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearCmtPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearCmtPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPit0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 0
 * interrupt vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPit0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPit0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPit1Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 1
 * interrupt vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPit1Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPit1Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPit2Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 2
 * interrupt vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPit2Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPit2Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPit3Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 3
 * interrupt vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPit3Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPit3Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortAPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port a pin detect interrupt vector
 * number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortAPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortAPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortBPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port b pin detect interrupt vector
 * number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortBPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortBPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortCPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port c pin detect interrupt vector
 * number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortCPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortCPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortDPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port d pin detect interrupt vector
 * number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortDPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortDPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPortEPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port e pin detect interrupt vector
 * number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPortEPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPortEPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearSwiPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearSwiPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearSwiPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- GetDma4Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 4 transfer complete IRQ is
 * enabled for vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma4Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma4Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma5Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 5 transfer complete IRQ is
 * enabled for vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma5Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma5Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma6Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 6 transfer complete IRQ is
 * enabled for vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma6Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma6Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x40U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma7Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 7 transfer complete IRQ is
 * enabled for vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma7Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma7Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma8Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 8 transfer complete IRQ is
 * enabled for vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma8Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma8Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x100U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma9Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 9 transfer complete IRQ is
 * enabled for vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma9Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma9Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x200U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma10Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 10 transfer complete IRQ is
 * enabled for vector number 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma10Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma10Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x400U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma11Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 11 transfer complete IRQ is
 * enabled for vector number 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma11Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma11Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x800U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma12Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 12 transfer complete IRQ is
 * enabled for vector number 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma12Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma12Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x1000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma13Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 13 transfer complete IRQ is
 * enabled for vector number 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma13Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma13Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x2000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma14Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 14 transfer complete IRQ is
 * enabled for vector number 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma14Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma14Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x4000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDma15Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DMA channel 15 transfer complete IRQ is
 * enabled for vector number 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDma15Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDma15Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x8000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetMcmEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the MCM normal IRQ is enabled for vector
 * number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetMcmEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetMcmEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FTFL command complete IRQ is enabled for
 * vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetFtflEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x40000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetFtflCollisionEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FTFL read collision IRQ is enabled for
 * vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result =
 *      NVIC_PDD_GetFtflCollisionEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetFtflCollisionEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetRngEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the randon number generator IRQ is enabled
 * for vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetRngEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetRngEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x800000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0TxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the integrated interchip sound 0 transmit
 * IRQ is enabled for vector number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2S0TxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0TxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x10000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetI2S0RxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the integrated interchip sound 0 receive IRQ
 * is enabled for vector number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetI2S0RxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetI2S0RxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x20000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0RxTxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 receive/transmit IRQ is enabled
 * for vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0RxTxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0RxTxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,0U) & 0x80000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart0ErrEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 error IRQ is enabled for vector
 * number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart0ErrEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart0ErrEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1RxTxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 receive/transmit IRQ is enabled
 * for vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1RxTxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1RxTxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart1ErrEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 error IRQ is enabled for vector
 * number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart1ErrEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart1ErrEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2RxTxEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 receive/transmit IRQ is enabled
 * for vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2RxTxEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2RxTxEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUart2ErrEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 error IRQ is enabled for vector
 * number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUart2ErrEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUart2ErrEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10U) \
  )

/* ----------------------------------------------------------------------------
   -- GetCmtEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the carrier modulator transmitter IRQ is
 * enabled for vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetCmtEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetCmtEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 0 IRQ
 * is enabled for vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit1Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 1 IRQ
 * is enabled for vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit1Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit1Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x20000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit2Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 2 IRQ
 * is enabled for vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit2Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit2Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x40000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPit3Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 3 IRQ
 * is enabled for vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPit3Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPit3Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortAEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port a pin detect IRQ is enabled for
 * vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortAEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortAEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortBEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port b pin detect IRQ is enabled for
 * vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortBEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortBEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortCEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port c pin detect IRQ is enabled for
 * vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortCEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortCEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x20000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortDEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port d pin detect IRQ is enabled for
 * vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortDEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortDEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x40000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPortEEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port e pin detect IRQ is enabled for
 * vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPortEEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPortEEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetSwiEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the software IRQ is enabled for vector
 * number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetSwiEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetSwiEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,2U) & 0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma4
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 4 transfer complete interrupt vector number 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma4(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma4(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma5
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 5 transfer complete interrupt vector number 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma5(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma5(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x20U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma6
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 6 transfer complete interrupt vector number 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma6(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma6(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x40U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma7
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 7 transfer complete interrupt vector number 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma7(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma7(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma8
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 8 transfer complete interrupt vector number 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma8(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma8(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma9
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 9 transfer complete interrupt vector number 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma9(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma9(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma10
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 10 transfer complete interrupt vector number
 * 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma10(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma10(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma11
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 11 transfer complete interrupt vector number
 * 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma11(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma11(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma12
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 12 transfer complete interrupt vector number
 * 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma12(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma12(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma13
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 13 transfer complete interrupt vector number
 * 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma13(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma13(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma14
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 14 transfer complete interrupt vector number
 * 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma14(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma14(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableDma15
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DMA channel 15 transfer complete interrupt vector number
 * 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDma15(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDma15(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableMcm
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the MCM normal interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableMcm(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableMcm(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableFtfl
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the FTFL command complete interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtfl(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableFtfl(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableFtflCollision
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the FTFL read collision interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableFtflCollision(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableFtflCollision(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableRng
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the randon number generator interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableRng(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableRng(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableI2S0Tx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the integrated interchip sound 0 transmit interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2S0Tx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableI2S0Tx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableI2S0Rx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the integrated interchip sound 0 receive interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableI2S0Rx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableI2S0Rx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart0RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART0 receive/transmit interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart0RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart0RxTx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,0U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart0Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART0 error interrupt vector number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart0Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart0Err(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart1RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART1 receive/transmit interrupt vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart1RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart1RxTx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart1Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART1 error interrupt vector number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart1Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart1Err(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart2RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART2 receive/transmit interrupt vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart2RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart2RxTx(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUart2Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART2 error interrupt vector number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUart2Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUart2Err(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- EnableCmt
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the carrier modulator transmitter interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableCmt(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableCmt(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePit0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 0 interrupt vector number
 * 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePit0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePit0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePit1
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 1 interrupt vector number
 * 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePit1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePit1(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePit2
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 2 interrupt vector number
 * 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePit2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePit2(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePit3
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 3 interrupt vector number
 * 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePit3(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePit3(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortA
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port a pin detect interrupt vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortA(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortA(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortB
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port b pin detect interrupt vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortB(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortB(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortC
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port c pin detect interrupt vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortC(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortC(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortD
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port d pin detect interrupt vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortD(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortD(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnablePortE
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port e pin detect interrupt vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnablePortE(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnablePortE(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableSwi
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableSwi(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableSwi(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma4
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 4 transfer complete interrupt vector number
 * 20.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma4(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma4(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma5
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 5 transfer complete interrupt vector number
 * 21.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma5(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma5(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x20U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma6
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 6 transfer complete interrupt vector number
 * 22.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma6(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma6(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x40U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma7
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 7 transfer complete interrupt vector number
 * 23.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma7(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma7(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma8
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 8 transfer complete interrupt vector number
 * 24.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma8(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma8(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma9
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 9 transfer complete interrupt vector number
 * 25.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma9(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma9(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma10
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 10 transfer complete interrupt vector number
 * 26.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma10(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma10(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma11
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 11 transfer complete interrupt vector number
 * 27.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma11(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma11(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma12
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 12 transfer complete interrupt vector number
 * 28.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma12(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma12(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma13
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 13 transfer complete interrupt vector number
 * 29.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma13(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma13(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma14
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 14 transfer complete interrupt vector number
 * 30.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma14(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma14(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDma15
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DMA channel 15 transfer complete interrupt vector number
 * 31.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDma15(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDma15(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableMcm
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the MCM normal interrupt vector number 33.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableMcm(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableMcm(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableFtfl
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the FTFL command complete interrupt vector number 34.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtfl(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableFtfl(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableFtflCollision
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the FTFL read collision interrupt vector number 35.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableFtflCollision(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableFtflCollision(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableRng
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the randon number generator interrupt vector number 39.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableRng(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableRng(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableI2S0Tx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the integrated interchip sound 0 transmit interrupt vector
 * number 44.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2S0Tx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableI2S0Tx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableI2S0Rx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the integrated interchip sound 0 receive interrupt vector
 * number 45.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableI2S0Rx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableI2S0Rx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart0RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART0 receive/transmit interrupt vector number 47.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart0RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart0RxTx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,0U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart0Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART0 error interrupt vector number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart0Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart0Err(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart1RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART1 receive/transmit interrupt vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart1RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart1RxTx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart1Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART1 error interrupt vector number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart1Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart1Err(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart2RxTx
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART2 receive/transmit interrupt vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart2RxTx(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart2RxTx(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUart2Err
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART2 error interrupt vector number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUart2Err(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUart2Err(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- DisableCmt
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the carrier modulator transmitter interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableCmt(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableCmt(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePit0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 0 interrupt vector
 * number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePit0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePit0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePit1
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 1 interrupt vector
 * number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePit1(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePit1(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePit2
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 2 interrupt vector
 * number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePit2(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePit2(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePit3
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 3 interrupt vector
 * number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePit3(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePit3(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortA
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port a pin detect interrupt vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortA(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortA(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortB
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port b pin detect interrupt vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortB(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortB(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortC
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port c pin detect interrupt vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortC(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortC(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortD
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port d pin detect interrupt vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortD(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortD(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisablePortE
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port e pin detect interrupt vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisablePortE(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisablePortE(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableSwi
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableSwi(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableSwi(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 error IRQ is pending for vector
 * number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector48(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 receive/transmit IRQ is pending
 * for vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector49(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 1U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 error IRQ is pending for vector
 * number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector50(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 2U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 receive/transmit IRQ is pending
 * for vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector51(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 3U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 error IRQ is pending for vector
 * number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector52(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 4U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the analog-to-digital converter 0 IRQ is
 * pending for vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector55(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 7U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the comparator 0 IRQ is pending for vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector56(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 8U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the comparator 1 IRQ is pending for vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector57(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 9U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 0 fault, overflow and
 * channels IRQ is pending for vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector58(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 10U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 1 fault, overflow and
 * channels IRQ is pending for vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector59(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 11U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 2 fault, overflow and
 * channels IRQ is pending for vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector60(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 12U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the carrier modulator transmitter IRQ is
 * pending for vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector61(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 13U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the real time clock IRQ is pending for
 * vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector62(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 14U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is pending
 * for vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector63(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 15U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 0 IRQ
 * is pending for vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector64(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 16U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 1 IRQ
 * is pending for vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector65(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 17U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 2 IRQ
 * is pending for vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector66(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 18U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 3 IRQ
 * is pending for vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector67(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 19U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the programmable delay block IRQ is pending
 * for vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector68(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 20U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * pending for vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector73(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 25U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the low power timer IRQ is pending for
 * vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector74(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 26U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port a pin detect IRQ is pending for
 * vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector75(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 27U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port b pin detect IRQ is pending for
 * vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector76(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 28U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port c pin detect IRQ is pending for
 * vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector77(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 29U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port d pin detect IRQ is pending for
 * vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector78(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 30U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port e pin detect IRQ is pending for
 * vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector79(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 31U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the software IRQ is pending for vector
 * number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector80(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,2U) & (uint32_t)0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART0 error interrupt vector number 48 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector48(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART1 receive/transmit interrupt vector number 49 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector49(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART1 error interrupt vector number 50 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector50(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART2 receive/transmit interrupt vector number 51 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector51(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces UART2 error interrupt vector number 52 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector52(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces analog-to-digital converter 0 interrupt vector number 55 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector55(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces comparator 0 interrupt vector number 56 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector56(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces comparator 1 interrupt vector number 57 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector57(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector58(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector59(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector60(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces carrier modulator transmitter interrupt vector number 61 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector61(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces real time clock interrupt vector number 62 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector62(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces real time clock seconds interrupt vector number 63 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector63(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 0 interrupt vector number 64
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector64(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 1 interrupt vector number 65
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector65(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 2 interrupt vector number 66
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector66(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces periodic interrupt timer channel 3 interrupt vector number 67
 * into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector67(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces programmable delay block interrupt vector number 68 into the
 * pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector68(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x100000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces multipurpose clock generator interrupt vector number 73 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector73(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x2000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces low power timer interrupt vector number 74 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector74(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x4000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port a pin detect interrupt vector number 75 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector75(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port b pin detect interrupt vector number 76 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector76(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port c pin detect interrupt vector number 77 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector77(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port d pin detect interrupt vector number 78 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector78(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces port e pin detect interrupt vector number 79 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector79(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces software interrupt vector number 80 into the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector80(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART0 error interrupt vector number
 * 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector48(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART1 receive/transmit interrupt
 * vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector49(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART1 error interrupt vector number
 * 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector50(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART2 receive/transmit interrupt
 * vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector51(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the UART2 error interrupt vector number
 * 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector52(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the analog-to-digital converter 0
 * interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector55(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the comparator 0 interrupt vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector56(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the comparator 1 interrupt vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector57(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the FlexTimer module 0 fault, overflow
 * and channels interrupt vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector58(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the FlexTimer module 1 fault, overflow
 * and channels interrupt vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector59(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the FlexTimer module 2 fault, overflow
 * and channels interrupt vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector60(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the carrier modulator transmitter
 * interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector61(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the real time clock interrupt vector
 * number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector62(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the real time clock seconds interrupt
 * vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector63(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 0
 * interrupt vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector64(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 1
 * interrupt vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector65(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 2
 * interrupt vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector66(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the periodic interrupt timer channel 3
 * interrupt vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector67(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the programmable delay block interrupt
 * vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector68(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x100000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the multipurpose clock generator
 * interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector73(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x2000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the low power timer interrupt vector
 * number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector74(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x4000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port a pin detect interrupt vector
 * number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector75(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port b pin detect interrupt vector
 * number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector76(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port c pin detect interrupt vector
 * number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector77(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port d pin detect interrupt vector
 * number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector78(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the port e pin detect interrupt vector
 * number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector79(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector80(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART0 error IRQ is enabled for vector
 * number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector48(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 receive/transmit IRQ is enabled
 * for vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector49(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART1 error IRQ is enabled for vector
 * number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector50(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 receive/transmit IRQ is enabled
 * for vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector51(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the UART2 error IRQ is enabled for vector
 * number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector52(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the analog-to-digital converter 0 IRQ is
 * enabled for vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector55(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the comparator 0 IRQ is enabled for vector
 * number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector56(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x100U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the comparator 1 IRQ is enabled for vector
 * number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector57(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x200U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 0 fault, overflow and
 * channels IRQ is enabled for vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector58(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x400U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 1 fault, overflow and
 * channels IRQ is enabled for vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector59(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x800U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the FlexTimer module 2 fault, overflow and
 * channels IRQ is enabled for vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector60(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x1000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the carrier modulator transmitter IRQ is
 * enabled for vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector61(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the real time clock IRQ is enabled for
 * vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector62(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the real time clock seconds IRQ is enabled
 * for vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector63(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 0 IRQ
 * is enabled for vector number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector64(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 1 IRQ
 * is enabled for vector number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector65(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x20000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 2 IRQ
 * is enabled for vector number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector66(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x40000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the periodic interrupt timer channel 3 IRQ
 * is enabled for vector number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector67(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the programmable delay block IRQ is enabled
 * for vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector68(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x100000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the multipurpose clock generator IRQ is
 * enabled for vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector73(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x2000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the low power timer IRQ is enabled for
 * vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector74(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x4000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port a pin detect IRQ is enabled for
 * vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector75(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x8000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port b pin detect IRQ is enabled for
 * vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector76(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x10000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port c pin detect IRQ is enabled for
 * vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector77(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x20000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port d pin detect IRQ is enabled for
 * vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector78(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x40000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the port e pin detect IRQ is enabled for
 * vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector79(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x80000000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the software IRQ is enabled for vector
 * number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector80(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,2U) & 0x1U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART0 error interrupt vector number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector48(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART1 receive/transmit interrupt vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector49(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART1 error interrupt vector number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector50(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART2 receive/transmit interrupt vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector51(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the UART2 error interrupt vector number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector52(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the analog-to-digital converter 0 interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector55(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the comparator 0 interrupt vector number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector56(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the comparator 1 interrupt vector number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector57(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector58(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector59(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector60(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the carrier modulator transmitter interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector61(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the real time clock interrupt vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector62(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the real time clock seconds interrupt vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector63(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 0 interrupt vector number
 * 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector64(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 1 interrupt vector number
 * 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector65(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 2 interrupt vector number
 * 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector66(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the periodic interrupt timer channel 3 interrupt vector number
 * 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector67(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the programmable delay block interrupt vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector68(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x100000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the multipurpose clock generator interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector73(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x2000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the low power timer interrupt vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector74(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x4000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port a pin detect interrupt vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector75(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port b pin detect interrupt vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector76(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port c pin detect interrupt vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector77(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port d pin detect interrupt vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector78(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the port e pin detect interrupt vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector79(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector80(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector48
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART0 error interrupt vector number 48.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector48(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector48(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector49
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART1 receive/transmit interrupt vector number 49.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector49(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector49(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x2U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector50
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART1 error interrupt vector number 50.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector50(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector50(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x4U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector51
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART2 receive/transmit interrupt vector number 51.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector51(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector51(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x8U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector52
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the UART2 error interrupt vector number 52.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector52(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector52(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector55
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the analog-to-digital converter 0 interrupt vector number 55.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector55(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector55(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x80U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector56
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the comparator 0 interrupt vector number 56.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector56(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector56(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x100U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector57
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the comparator 1 interrupt vector number 57.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector57(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector57(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x200U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector58
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the FlexTimer module 0 fault, overflow and channels interrupt
 * vector number 58.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector58(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector58(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x400U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector59
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the FlexTimer module 1 fault, overflow and channels interrupt
 * vector number 59.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector59(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector59(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x800U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector60
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the FlexTimer module 2 fault, overflow and channels interrupt
 * vector number 60.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector60(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector60(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x1000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector61
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the carrier modulator transmitter interrupt vector number 61.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector61(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector61(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x2000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector62
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the real time clock interrupt vector number 62.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector62(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector62(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x4000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector63
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the real time clock seconds interrupt vector number 63.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector63(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector63(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x8000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector64
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 0 interrupt vector
 * number 64.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector64(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector64(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector65
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 1 interrupt vector
 * number 65.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector65(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector65(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x20000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector66
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 2 interrupt vector
 * number 66.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector66(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector66(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x40000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector67
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the periodic interrupt timer channel 3 interrupt vector
 * number 67.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector67(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector67(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x80000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector68
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the programmable delay block interrupt vector number 68.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector68(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector68(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x100000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector73
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the multipurpose clock generator interrupt vector number 73.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector73(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector73(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x2000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector74
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the low power timer interrupt vector number 74.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector74(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector74(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x4000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector75
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port a pin detect interrupt vector number 75.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector75(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector75(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x8000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector76
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port b pin detect interrupt vector number 76.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector76(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector76(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x10000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector77
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port c pin detect interrupt vector number 77.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector77(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector77(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x20000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector78
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port d pin detect interrupt vector number 78.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector78(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector78(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x40000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector79
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the port e pin detect interrupt vector number 79.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector79(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector79(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x80000000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector80
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the software interrupt vector number 80.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector80(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector80(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,2U) = \
     0x1U \
  )

/* ----------------------------------------------------------------------------
   -- SetDryPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DryIce tamper detect interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDryPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetDryPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,55U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetDryPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DryIce tamper detect interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetDryPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDryPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,55U) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the DryIce tamper detect interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector71(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector71(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,55U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the DryIce tamper detect interrupt
 * interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector71(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,55U) \
  )

/* ----------------------------------------------------------------------------
   -- GetDryPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DryIce tamper detect interrupt IRQ is
 * pending for vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDryPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDryPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 23U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetDryPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DryIce tamper detect interrupt interrupt vector number 71 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetDryPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetDryPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearDryPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DryIce tamper detect interrupt
 * interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearDryPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearDryPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- GetDryEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DryIce tamper detect interrupt IRQ is
 * enabled for vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetDryEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetDryEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x800000U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableDry
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DryIce tamper detect interrupt interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableDry(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableDry(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableDry
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DryIce tamper detect interrupt interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableDry(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableDry(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DryIce tamper detect interrupt IRQ is
 * pending for vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector71(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 23U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces DryIce tamper detect interrupt interrupt vector number 71 into
 * the pending state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector71(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the DryIce tamper detect interrupt
 * interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector71(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the DryIce tamper detect interrupt IRQ is
 * enabled for vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector71(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x800000U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the DryIce tamper detect interrupt interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector71(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector71
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the DryIce tamper detect interrupt interrupt vector number 71.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector71(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector71(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x800000U \
  )

/* ----------------------------------------------------------------------------
   -- SetUsb0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the USB OTG interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUsb0Priority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUsb0Priority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,53U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetUsbDcdPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the USB charger detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUsbDcdPriority(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetUsbDcdPriority(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,54U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetUsb0Priority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the USB OTG interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUsb0Priority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsb0Priority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,53U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUsbDcdPriority
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the USB charger detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetUsbDcdPriority(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsbDcdPriority(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,54U) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the USB OTG interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector69(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector69(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,53U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- SetPriorityVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Sets the interrupt priority of the USB charger detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @param Priority Parameter specifying interrupt vector priority. Only
 *        priorities 240(lowest), 224, 208, 192, 176, 160, 144, 128, 112, 96, 80, 64, 48,
 *        32, 16 and 0(highest) are valid. This parameter is a 8-bit value.
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPriorityVector70(<peripheral>_BASE_PTR, 1);
 *      @endcode
 */
#define NVIC_PDD_SetPriorityVector70(PeripheralBase, Priority) ( \
    NVIC_IP_REG(PeripheralBase,54U) = \
     (uint8_t)(Priority) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the USB OTG interrupt interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector69(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,53U) \
  )

/* ----------------------------------------------------------------------------
   -- GetPriorityVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns the interrupt priority of the USB charger detect interrupt.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 8-bit value.
 * @remarks The macro accesses the following registers: IP[].
 * @par Example:
 *      @code
 *      uint8_t result = NVIC_PDD_GetPriorityVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPriorityVector70(PeripheralBase) ( \
    NVIC_IP_REG(PeripheralBase,54U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUsb0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB OTG interrupt IRQ is pending for
 * vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUsb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsb0Pending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 21U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetUsbDcdPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB charger detect IRQ is pending for
 * vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUsbDcdPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsbDcdPending(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 22U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetUsb0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces USB OTG interrupt interrupt vector number 69 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUsb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUsb0Pending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- SetUsbDcdPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces USB charger detect interrupt vector number 70 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetUsbDcdPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetUsbDcdPending(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUsb0Pending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the USB OTG interrupt interrupt vector
 * number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUsb0Pending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUsb0Pending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearUsbDcdPending
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the USB charger detect interrupt vector
 * number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearUsbDcdPending(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearUsbDcdPending(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- GetUsb0Enabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB OTG interrupt IRQ is enabled for
 * vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUsb0Enabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsb0Enabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x200000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetUsbDcdEnabled
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB charger detect IRQ is enabled for
 * vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetUsbDcdEnabled(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetUsbDcdEnabled(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x400000U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableUsb0
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the USB OTG interrupt interrupt vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUsb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUsb0(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableUsbDcd
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the USB charger detect interrupt vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableUsbDcd(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableUsbDcd(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUsb0
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the USB OTG interrupt interrupt vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUsb0(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUsb0(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableUsbDcd
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the USB charger detect interrupt vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableUsbDcd(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableUsbDcd(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB OTG interrupt IRQ is pending for
 * vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector69(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 21U)) \
  )

/* ----------------------------------------------------------------------------
   -- GetPendingVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB charger detect IRQ is pending for
 * vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetPendingVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetPendingVector70(PeripheralBase) ( \
    (uint32_t)(NVIC_ISPR_REG(PeripheralBase,1U) & (uint32_t)((uint32_t)0x1U << 22U)) \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces USB OTG interrupt interrupt vector number 69 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector69(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- SetPendingVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Forces USB charger detect interrupt vector number 70 into the pending
 * state.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_SetPendingVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_SetPendingVector70(PeripheralBase) ( \
    NVIC_ISPR_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the USB OTG interrupt interrupt vector
 * number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector69(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- ClearPendingVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Removes the pending state from the USB charger detect interrupt vector
 * number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICPR[].
 * @par Example:
 *      @code
 *      NVIC_PDD_ClearPendingVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_ClearPendingVector70(PeripheralBase) ( \
    NVIC_ICPR_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB OTG interrupt IRQ is enabled for
 * vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector69(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x200000U) \
  )

/* ----------------------------------------------------------------------------
   -- GetEnabledVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Returns non-zero value if the USB charger detect IRQ is enabled for
 * vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a 32-bit value.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      uint32_t result = NVIC_PDD_GetEnabledVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_GetEnabledVector70(PeripheralBase) ( \
    (uint32_t)(NVIC_ISER_REG(PeripheralBase,1U) & 0x400000U) \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the USB OTG interrupt interrupt vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector69(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- EnableVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Enables the USB charger detect interrupt vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ISER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_EnableVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_EnableVector70(PeripheralBase) ( \
    NVIC_ISER_REG(PeripheralBase,1U) = \
     0x400000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector69
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the USB OTG interrupt interrupt vector number 69.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector69(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector69(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x200000U \
  )

/* ----------------------------------------------------------------------------
   -- DisableVector70
   ---------------------------------------------------------------------------- */

/**
 * @brief Disables the USB charger detect interrupt vector number 70.
 * @param PeripheralBase Pointer to a peripheral registers structure (peripheral
 *        base address). You can use the constant defined in the registers
 *        definition header file (<peripheral>_BASE_PTR) or the constant defined in
 *        the peripheral initialization component header file
 *        (<component_name>_DEVICE).
 * @return Returns a value of void type.
 * @remarks The macro accesses the following registers: ICER[].
 * @par Example:
 *      @code
 *      NVIC_PDD_DisableVector70(<peripheral>_BASE_PTR);
 *      @endcode
 */
#define NVIC_PDD_DisableVector70(PeripheralBase) ( \
    NVIC_ICER_REG(PeripheralBase,1U) = \
     0x400000U \
  )
#endif  /* #if defined(NVIC_PDD_H_) */

/* NVIC_PDD.h, eof. */
